<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flax Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="fundamentals/index.html"><strong aria-hidden="true">1.</strong> Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/world.html"><strong aria-hidden="true">1.1.</strong> World</a></li><li class="chapter-item expanded "><a href="fundamentals/components.html"><strong aria-hidden="true">1.2.</strong> Components</a></li><li class="chapter-item expanded "><a href="fundamentals/query.html"><strong aria-hidden="true">1.3.</strong> Queries</a></li><li class="chapter-item expanded "><a href="fundamentals/systems.html"><strong aria-hidden="true">1.4.</strong> Systems</a></li><li class="chapter-item expanded "><a href="fundamentals/schedule.html"><strong aria-hidden="true">1.5.</strong> Schedule</a></li><li class="chapter-item expanded "><a href="fundamentals/builder.html"><strong aria-hidden="true">1.6.</strong> EntityBuilder</a></li><li class="chapter-item expanded "><a href="fundamentals/commandbuffer.html"><strong aria-hidden="true">1.7.</strong> CommandBuffer</a></li><li class="chapter-item expanded "><a href="fundamentals/relations.html"><strong aria-hidden="true">1.8.</strong> Relations</a></li><li class="chapter-item expanded "><a href="fundamentals/metadata.html"><strong aria-hidden="true">1.9.</strong> Component metadata</a></li></ol></li><li class="chapter-item expanded "><a href="query/index.html"><strong aria-hidden="true">2.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query/basics.html"><strong aria-hidden="true">2.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="query/filters.html"><strong aria-hidden="true">2.2.</strong> Filters</a></li><li class="chapter-item expanded "><a href="query/change_detection.html"><strong aria-hidden="true">2.3.</strong> Change Detection</a></li><li class="chapter-item expanded "><a href="query/entity_query.html"><strong aria-hidden="true">2.4.</strong> Entity Query</a></li><li class="chapter-item expanded "><a href="query/graphs.html"><strong aria-hidden="true">2.5.</strong> Graphs</a></li></ol></li><li class="chapter-item expanded "><a href="diving_deeper/index.html"><strong aria-hidden="true">3.</strong>  Diving deeper </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="diving_deeper/query.html"><strong aria-hidden="true">3.1.</strong> Advanced Queries</a></li><li class="chapter-item expanded "><a href="diving_deeper/dynamic_components.html"><strong aria-hidden="true">3.2.</strong> Dynamic Components</a></li><li class="chapter-item expanded "><a href="diving_deeper/serde.html"><strong aria-hidden="true">3.3.</strong> Serialization</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flax Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Flax is an easy to use Entity Component System.</p>
<h2 id="what-is-an-ecs"><a class="header" href="#what-is-an-ecs">What is an ECS</a></h2>
<p>ECS, or Entity Component System is a design paradigm of where the state of the
program is structured around multiple <em>Entities</em>, where each entity may have
zero or more components attached to it.</p>
<p>Systems execute upon the entities and their components.</p>
<p>The main benefit of this priniciple is that the logic is separate from the data,
and new functionality can be added to existing entities and components.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>In Flax, there are 3 fundamental building blocks.</p>
<p><a href="https://docs.rs/flax/latest/flax/struct.Entity.html">Entity</a>. A unique identifier for the entities of the program. Has a managed lifecycle.</p>
<p><a href="https://docs.rs/flax/latest/flax/struct.Component.html">Component</a>, data which
can be added to an Entity. Has a unique Id, which works as the key for storing
and retrieving the value, and a strongly typed value.</p>
<p><a href="https://docs.rs/flax/latest/flax/struct.System.html">System</a> functions which
execute on the world or a group of entities. Provides the logic of the program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<p>This chapter goes through the basic of using Flax.</p>
<p>To get started, add <code>flax</code> to the <code>Cargo.toml</code> file</p>
<pre><code class="language-toml">flax = &quot;0.2&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world"><a class="header" href="#world">World</a></h1>
<p>The world holds the entities and components in the ECS.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut world = World::new();
<span class="boring">}</span></code></pre></pre>
<p>Spawning an entity yields an <code>Entity</code> id.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let id = world.spawn();

    if world.is_alive(id) {
        println!(&quot;It is alive!&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>When an entity is despawned, it can no longer be accessed.</p>
<p>Entity ids are versioned, which means that once an entity is despawned the index
in the storage may be reused, but it will have a different version, which
prevents dead entities to become alive at a later point in time. I.e; dead
entities stay dead, this is not a zombie apocalypse we are working with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    world.despawn(id)?;

    if world.is_alive(id) {
        println!(&quot;We've got a zombie on our hands&quot;);
    }

<span class="boring">}</span></code></pre></pre>
<p>Many entities can be spawned at a time, which is easily demonstrated by this
iterator which takes entity ids from the world</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let ids = world.spawn_many().take(10).collect_vec();
    println!(&quot;ids: {ids:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>A component represents data which is attached to an entity.</p>
<p><strong>Note</strong>: Compared to other Rust ECS implementations, a component is not the
same as the underlying type. This allows different components of the same
<em>datatype</em> to coexist without having to use newtypes and forward all traits, and
implement <code>Into</code> and <code>From</code> implementations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// Represents the position in the world
        position: (f32, f32),
    }

<span class="boring">}</span></code></pre></pre>
<p>This in turn exposes a function that will return the component id, as component ids
are lazily allocated due to lack of compile time unique ids.</p>
<p>The component can be added, accessed and removed from entities using
<a href="https://docs.rs/flax/latest/flax/struct.World.html#method.set">World::set</a>,
<a href="https://docs.rs/flax/latest/flax/struct.World.html#method.get">World::get</a>, and
<a href="https://docs.rs/flax/latest/flax/struct.World.html#method.remove">World::remove</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let id = world.spawn();

    // Add a component to `id`
    world.set(id, position(), (1.0, 4.0))?;

    {
        let val = world.get(id, position())?;

        println!(&quot;The entity is at: {val:?}&quot;);
    }

    // This will overwrite the previous value
    world.set(id, position(), (1.0, 4.5))?;

    {
        // Mutate the component
        let mut pos = world.get_mut(id, position())?;
        pos.1 += 1.0;
    }

    println!(&quot;The entity is now at: {:?}&quot;, world.get(id, position())?);

<span class="boring">}</span></code></pre></pre>
<p>Accessing a component mutably does not require a mutable access to the world, as
it uses an AtomicRefCell.</p>
<p>Multiple <em>different</em> components can be accessed simultaneously, even on the same
entity.</p>
<h2 id="default-components"><a class="header" href="#default-components">Default components</a></h2>
<p>Flax provides some opinionated default components to ease the communication
between different libraries and users.</p>
<ul>
<li><a href="https://docs.rs/flax/latest/flax/components/fn.name.html">name</a>: Provides a name for entities and components.</li>
<li><a href="https://docs.rs/flax/latest/flax/components/fn.child_of.html">child_of</a>: Default dataless hierarchy relation. See: <a href="https://ten3roberts.github.io/flax/guide/fundamentals/relations.html">Relations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">Query</a></h1>
<p>A query is the beating heart of the ECS.</p>
<p>They provide a declarative method to iterate, modify, and inspect the world's entities and their components.</p>
<p>In short a query is a declaration of which components to access, though they allow for so much more, such as filtering or excluding entities with certain components, change detection, relationship and graph traversal and much much more.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use flax::{
</span><span class="boring">    component, entity_ids, CommandBuffer, Component, Debuggable, Entity, EntityBorrow, FetchExt,
</span><span class="boring">    Mutable, Query, QueryBorrow, Schedule, System, World,
</span><span class="boring">};
</span><span class="boring">use glam::{vec2, Vec2};
</span><span class="boring">use rand::{rngs::StdRng, Rng, SeedableRng};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; anyhow::Result&lt;()&gt; {
</span><span class="boring">    let mut world = World::new();
</span><span class="boring">
</span><span class="boring">    component! {
</span><span class="boring">        position: Vec2 =&gt; [ Debuggable ],
</span><span class="boring">        health: f32 =&gt; [ Debuggable ],
</span><span class="boring">    }
</span><span class="boring">
</span>    // Spawn two entities
    let id = Entity::builder()
        .set(position(), vec2(1.0, 4.0))
        .set(health(), 75.0)
        .spawn(&amp;mut world);

    let id2 = Entity::builder()
        .set(position(), vec2(-1.0, 4.0))
        .set(health(), 75.0)
        .spawn(&amp;mut world);

    let mut query = Query::new((position(), health()));

    for (pos, health) in &amp;mut query.borrow(&amp;world) {
        println!(&quot;pos: {pos:?}, health: {health}&quot;);
    }

<span class="boring">
</span><span class="boring">    component! {
</span><span class="boring">        /// Distance to origin
</span><span class="boring">        distance: f32 =&gt; [ flax::Debuggable ],
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    println!(&quot;Spawning id3&quot;);
</span><span class="boring">    let id3 = world.spawn();
</span><span class="boring">    world.set(id3, position(), vec2(5.0, 6.0))?;
</span><span class="boring">    world.set(id3, health(), 5.0)?;
</span><span class="boring">
</span><span class="boring">    for id in [id, id2, id3] {
</span><span class="boring">        println!(&quot;Adding distance to {id}&quot;);
</span><span class="boring">        world.set(id, distance(), 0.0)?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mut query = Query::new((entity_ids(), position(), distance().as_mut()))
</span><span class="boring">        .filter(position().modified() &amp; health().gt(0.0));
</span><span class="boring">
</span><span class="boring">    println!(&quot;Updating distances&quot;);
</span><span class="boring">    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
</span><span class="boring">        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
</span><span class="boring">        *dist = pos.length();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    println!(&quot;Running query again&quot;);
</span><span class="boring">    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
</span><span class="boring">        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
</span><span class="boring">        *dist = pos.length();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    *world.get_mut(id2, position())? = vec2(8.0, 3.0);
</span><span class="boring">
</span><span class="boring">    println!(&quot;... and again&quot;);
</span><span class="boring">    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
</span><span class="boring">        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
</span><span class="boring">        *dist = pos.length();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    #[allow(unused_variables)]
</span><span class="boring">    {
</span><span class="boring">        // Instead of this:
</span><span class="boring">        let query = Query::new((position(), health(), distance()))
</span><span class="boring">            .filter(position().modified() &amp; health().modified());
</span><span class="boring">
</span><span class="boring">        // Do this:
</span><span class="boring">        let query = Query::new((position().modified(), health().modified(), distance()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    let mut update_distance = System::builder()
</span><span class="boring">        .with_name(&quot;update_distance&quot;)
</span><span class="boring">        .with_query(query)
</span><span class="boring">        .build(
</span><span class="boring">            |mut query: QueryBorrow&lt;(_, Component&lt;Vec2&gt;, Mutable&lt;f32&gt;), _&gt;| {
</span><span class="boring">                for (id, pos, dist) in &amp;mut query {
</span><span class="boring">                    println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
</span><span class="boring">                    *dist = pos.length();
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">    update_distance.run(&amp;mut world);
</span><span class="boring">
</span><span class="boring">    let mut update_dist = System::builder()
</span><span class="boring">        .with_name(&quot;update_distance&quot;)
</span><span class="boring">        .with_query(
</span><span class="boring">            Query::new((entity_ids(), position(), distance().as_mut()))
</span><span class="boring">                .filter(position().modified()),
</span><span class="boring">        )
</span><span class="boring">        .for_each(|(id, pos, dist)| {
</span><span class="boring">            tracing::debug!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
</span><span class="boring">            *dist = pos.length();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    for _ in 0..16 {
</span><span class="boring">        update_dist.run(&amp;mut world);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // Despawn all entities with a distance &gt; 50
</span><span class="boring">    let despawn = System::builder()
</span><span class="boring">        .with_name(&quot;delete_outside_world&quot;)
</span><span class="boring">        .with_query(Query::new((entity_ids(), distance())).filter(distance().gt(50.0)))
</span><span class="boring">        .with_cmd_mut()
</span><span class="boring">        .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
</span><span class="boring">            for (id, &amp;dist) in &amp;mut q {
</span><span class="boring">                println!(&quot;Despawning {id} at: {dist}&quot;);
</span><span class="boring">                cmd.despawn(id);
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    let debug_world = System::builder()
</span><span class="boring">        .with_name(&quot;debug_world&quot;)
</span><span class="boring">        .with_world()
</span><span class="boring">        .build(|world: &amp;_| {
</span><span class="boring">            tracing::debug!(&quot;World: {world:?}&quot;);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    component! {
</span><span class="boring">        is_static: () =&gt; [ flax::Debuggable ],
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Spawn 150 static entities, which wont move
</span><span class="boring">    let mut rng = StdRng::seed_from_u64(42);
</span><span class="boring">
</span><span class="boring">    for _ in 0..150 {
</span><span class="boring">        let pos = vec2(rng.gen_range(-5.0..5.0), rng.gen_range(-5.0..5.0));
</span><span class="boring">        Entity::builder()
</span><span class="boring">            .set(position(), pos)
</span><span class="boring">            .set_default(distance())
</span><span class="boring">            .set_default(is_static())
</span><span class="boring">            .spawn(&amp;mut world);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Since this system will move non static entities out from the origin, they will
</span><span class="boring">    // eventually be despawned
</span><span class="boring">    let move_out = System::builder()
</span><span class="boring">        .with_name(&quot;move_out&quot;)
</span><span class="boring">        .with_query(Query::new(position().as_mut()).filter(is_static().without()))
</span><span class="boring">        .for_each(|pos| {
</span><span class="boring">            let dir = pos.normalize_or_zero();
</span><span class="boring">
</span><span class="boring">            *pos += dir;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    // Spawn new entities with a random position each frame
</span><span class="boring">    let spawn = System::builder().with_name(&quot;spawner&quot;).with_cmd_mut().build(
</span><span class="boring">        move |cmd: &amp;mut CommandBuffer| {
</span><span class="boring">            for _ in 0..100 {
</span><span class="boring">                let pos = vec2(rng.gen_range(-10.0..10.0), rng.gen_range(-10.0..10.0));
</span><span class="boring">                println!(&quot;Spawning new entity at: {pos:?}&quot;);
</span><span class="boring">                Entity::builder()
</span><span class="boring">                    .set(position(), pos)
</span><span class="boring">                    .set_default(distance())
</span><span class="boring">                    .spawn_into(cmd);
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let mut frame_count = 0;
</span><span class="boring">
</span><span class="boring">    // Count the number of entities in the world and log it
</span><span class="boring">    let count = System::builder()
</span><span class="boring">        .with_name(&quot;count&quot;)
</span><span class="boring">        .with_query(Query::new(()))
</span><span class="boring">        .build(move |mut query: QueryBorrow&lt;()&gt;| {
</span><span class="boring">            let count: usize = query.iter_batched().map(|v| v.len()).sum();
</span><span class="boring">            println!(&quot;[{frame_count}]: {count}&quot;);
</span><span class="boring">            frame_count += 1;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    // Assemble the schedule, takes care of dependency management
</span><span class="boring">    let mut schedule = Schedule::builder()
</span><span class="boring">        .with_system(update_dist)
</span><span class="boring">        .with_system(despawn)
</span><span class="boring">        .with_system(spawn)
</span><span class="boring">        .with_system(move_out)
</span><span class="boring">        .with_system(debug_world)
</span><span class="boring">        .with_system(count)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    println!(&quot;{schedule:#?}&quot;);
</span><span class="boring">
</span><span class="boring">    for i in 0..20 {
</span><span class="boring">        println!(&quot;Frame: {i}&quot;);
</span><span class="boring">        println!(&quot;Batches: {:#?}&quot;, schedule.batch_info(&amp;world));
</span><span class="boring">        schedule.execute_par(&amp;mut world)?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    component! {
</span><span class="boring">        window_width: f32,
</span><span class="boring">        window_height: f32,
</span><span class="boring">        allow_vsync: bool,
</span><span class="boring">
</span><span class="boring">        /// A static entity, which is always alive
</span><span class="boring">        resources,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Entity::builder()
</span><span class="boring">        .set(window_width(), 800.0)
</span><span class="boring">        .set(window_height(), 600.0)
</span><span class="boring">        .set(allow_vsync(), false)
</span><span class="boring">        // Since `resources` is static, it is not required to spawn it
</span><span class="boring">        .append_to(&amp;mut world, resources())
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let mut query = Query::new((window_width(), window_height(), allow_vsync()))
</span><span class="boring">        // Change the query strategy to only iterate the `resources` entity
</span><span class="boring">        .entity(resources());
</span><span class="boring">
</span><span class="boring">    let mut borrow = query.borrow(&amp;world);
</span><span class="boring">    let (width, height, vsync) = borrow.get().unwrap();
</span><span class="boring">    println!(&quot;width: {width} height: {height}, vsync: {vsync}&quot;);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    drop(borrow);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    let mut window_system = System::builder()
</span><span class="boring">        .with_query(query)
</span><span class="boring">        .build(|mut q: EntityBorrow&lt;_&gt;| {
</span><span class="boring">            if let Ok((width, height, allow_vsync)) = q.get() {
</span><span class="boring">                println!(
</span><span class="boring">                    &quot;Config changed width: {width}, height: {height}, allow_vsync: {allow_vsync}&quot;
</span><span class="boring">                );
</span><span class="boring">            } else {
</span><span class="boring">                println!(&quot;No config change&quot;);
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    window_system.run(&amp;mut world);
</span><span class="boring">    window_system.run(&amp;mut world);
</span><span class="boring">    world.set(resources(), window_height(), 720.0)?;
</span><span class="boring">    window_system.run(&amp;mut world);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>A query accepts any type which implements
<a href="https://docs.rs/flax/latest/flax/fetch/trait.Fetch.html">Fetch</a>, such as</p>
<ul>
<li>A component</li>
<li>A tuple of components</li>
<li><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.as_mut"><code>component.as_mut()</code></a> for mutable access</li>
<li><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.as_cloned"><code>component.as_cloned()</code></a> for cloning the values</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt"><code>component.opt()</code></a> for an optional access, returns Option&lt;&amp;T&gt;,</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt"><code>component.as_mut().opt()</code></a> for an optional mutable access, returns Option&lt;&amp;mut T&gt;,</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or_default"><code>component.opt_or_default()</code></a> for returning the default value if the component is not present</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or"><code>component.opt_or()</code></a> for returning a default if the component is not present</li>
<li><a href="https://docs.rs/flax/latest/flax/entity/fn.entity_ids.html"><code>entity_ids</code></a> to return the
iterated <code>Entity</code> ids.</li>
<li>... and many more</li>
<li></li>
</ul>
<p>See <a href="fundamentals/../query/index.html">Queries</a> for more details</p>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>A query allows for filters, such as skipping entities which have a certain
components, or where the value of a component satisfies some condition. This will efficiently skip entire archetypes or ranges of entities.</p>
<p>The following example shows a query which will update the distance to origin
when an entity moves for every entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// Distance to origin
        distance: f32 =&gt; [ flax::Debuggable ],
    }

    println!(&quot;Spawning id3&quot;);
    let id3 = world.spawn();
    world.set(id3, position(), vec2(5.0, 6.0))?;
    world.set(id3, health(), 5.0)?;

    for id in [id, id2, id3] {
        println!(&quot;Adding distance to {id}&quot;);
        world.set(id, distance(), 0.0)?;
    }

    let mut query = Query::new((entity_ids(), position(), distance().as_mut()))
        .filter(position().modified() &amp; health().gt(0.0));

    println!(&quot;Updating distances&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = pos.length();
    }

<span class="boring">}</span></code></pre></pre>
<p>The same query can be run again, but since all changes have been visited, it
yields nothing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    println!(&quot;Running query again&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = pos.length();
    }
<span class="boring">}</span></code></pre></pre>
<p>However, if the position were to be modified, the query would yield that one change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    *world.get_mut(id2, position())? = vec2(8.0, 3.0);

    println!(&quot;... and again&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = pos.length();
    }

<span class="boring">}</span></code></pre></pre>
<p>For situations where an <code>or</code> combined filter is used in conjunction with a fetch
of the same components, the filter may be attached directly to the query fetch
instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Instead of this:
        let query = Query::new((position(), health(), distance()))
            .filter(position().modified() &amp; health().modified());

        // Do this:
        let query = Query::new((position().modified(), health().modified(), distance()));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Maintaining queries and their associated data and logic can be verbose and error prone.</p>
<p><em>Systems</em> provide the perfect aid and allows bundling arguments, such as
queries, world access, and much more along with the logic to execute with it.</p>
<p>A system can be run manually or in a <a href="https://docs.rs/flax/0.4.0/flax/schedule/struct.Schedule.html"><code>Schedule</code></a>, which will automatically parallelize the system execution on multiple threads.</p>
<p>For example, to update <code>distance</code> from each <code>position</code> you could do:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let update_distance = System::builder()
            .with_name(&quot;update_distance&quot;)
            .with_query(Query::new((entity_ids(), position(), distance().as_mut())))
            .build(
                |mut query: QueryBorrow&lt;(_, Component&lt;Vec2&gt;, Mutable&lt;f32&gt;), _&gt;| {
                    for (id, pos, dist) in &amp;mut query {
                        println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
                        *dist = pos.length();
                    }
                },
            );
<span class="boring">}</span></code></pre></pre>
<p>The system construction can subsequently be extracted to a function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        fn update_distance_system() -&gt; BoxedSystem {
            System::builder()
                .with_name(&quot;update_distance&quot;)
                .with_query(Query::new((entity_ids(), position(), distance().as_mut())))
                .build(
                    |mut query: QueryBorrow&lt;(_, Component&lt;Vec2&gt;, Mutable&lt;f32&gt;), _&gt;| {
                        for (id, pos, dist) in &amp;mut query {
                            println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
                            *dist = pos.length();
                        }
                    },
                )
                .boxed()
        }
    }
    let mut update_distance = update_distance_system();

<span class="boring">}</span></code></pre></pre>
<p>However, the query won't yield entities since none have the <code>distance</code> component to modify. No to fear, we could add another system which ensures the component is present.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn add_distance_system() -&gt; BoxedSystem {
        let query = Query::new(entity_ids())
            .with(position())
            .without(distance());

        System::builder()
            .with_cmd_mut()
            .with_query(query)
            .build(
                |cmd: &amp;mut CommandBuffer, mut query: QueryBorrow&lt;'_, flax::EntityIds, _&gt;| {
                    for id in &amp;mut query {
                        cmd.set(id, distance(), 0.0);
                    }
                },
            )
            .boxed()
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="for-each"><a class="header" href="#for-each">For each</a></h2>
<p>Most systems iterate each item of a single query, without any other system arguments.</p>
<p>The shorthand <code>for_each</code> is provided for this purpose</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update_distance_system() -&gt; BoxedSystem {
        System::builder()
            .with_name(&quot;update_distance&quot;)
            .with_query(Query::new((entity_ids(), position(), distance().as_mut())))
            .for_each(|(id, pos, dist)| {
                println!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
                *dist = pos.length();
            })
            .boxed()
    }

<span class="boring">}</span></code></pre></pre>
<h2 id="schedule"><a class="header" href="#schedule">Schedule</a></h2>
<p>Lets add some more systems and add them to a <a href="https://docs.rs/flax/0.4.0/flax/schedule/struct.Schedule.html"><code>Schedule</code></a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Despawn all entities with a distance &gt; 50
    fn despawn_system() -&gt; BoxedSystem {
        System::builder()
            .with_name(&quot;delete_outside_world&quot;)
            .with_query(Query::new((entity_ids(), distance())).filter(distance().gt(50.0)))
            .with_cmd_mut()
            .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
                for (id, &amp;dist) in &amp;mut q {
                    println!(&quot;Despawning {id} at: {dist}&quot;);
                    cmd.despawn(id);
                }
            })
            .boxed()
    }

    fn inspect_system() -&gt; BoxedSystem {
        System::builder()
            .with_name(&quot;debug_world&quot;)
            .with_world()
            .build(|_world: &amp;_| {
                // println!(&quot;World: {_world:#?}&quot;);
            })
            .boxed()
    }

    component! {
        /// Entities with this component will not be moved
        is_static: () =&gt; [ flax::Debuggable ],
    }

    fn move_system() -&gt; BoxedSystem {
        System::builder()
            .with_name(&quot;move_out&quot;)
            .with_query(Query::new(position().as_mut()).filter(is_static().without()))
            .for_each(|pos| {
                let dir = pos.normalize_or_zero();

                *pos += dir;
            })
            .boxed()
    }

    // Since this system will move non static entities out from the origin, they will
    // eventually be despawned

    // Spawn new entities with a random position each frame
    fn spawn_system(mut rng: StdRng, count: usize) -&gt; BoxedSystem {
        System::builder()
            .with_name(&quot;spawn&quot;)
            .with_cmd_mut()
            .build(move |cmd: &amp;mut CommandBuffer| {
                for _ in 0..count {
                    let pos = vec2(rng.gen_range(-10.0..10.0), rng.gen_range(-10.0..10.0));
                    println!(&quot;Spawning new entity at: {pos:?}&quot;);
                    Entity::builder()
                        .set(position(), pos)
                        .set_default(distance())
                        .spawn_into(cmd);
                }
            })
            .boxed()
    }

    let rng = StdRng::seed_from_u64(42);

    // Assemble the schedule, takes care of dependency management
    let mut schedule = Schedule::builder()
        .with_system(add_distance_system())
        .flush()
        .with_system(update_distance_system())
        .with_system(despawn_system())
        .with_system(spawn_system(rng, 1))
        .with_system(move_system())
        .with_system(inspect_system())
        .build();

    for i in 0..20 {
        println!(&quot;Frame: {i}&quot;);
        schedule.execute_par(&amp;mut world)?;
    }


<span class="boring">}</span></code></pre></pre>
<h2 id="system-access"><a class="header" href="#system-access">System access</a></h2>
<p>One of the abilities of a system is to automatically extract what they need for their arguments from the schedule context.</p>
<p>This both increases their ease of use, but further assures that only the declared pieces of data will be accessed, which allows seamless fine-grained parallelization capabilities</p>
<p>Therefore, it is advised to keep your system arguments as <em>specific</em> as possible, such as using queries whenever possible, rather than the whole world.</p>
<p><strong>Note</strong>: Systems which access the world will not paralellize with other systems
as it may access anything.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Despawn all entities with a distance &gt; 50
    let despawn = System::builder()
        .with_name(&quot;delete_outside_world&quot;)
        .with_query(Query::new((entity_ids(), distance())).filter(distance().gt(50.0)))
        .with_cmd_mut()
        .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
            for (id, &amp;dist) in &amp;mut q {
                println!(&quot;Despawning {id} at: {dist}&quot;);
                cmd.despawn(id);
            }
        });

    let debug_world = System::builder()
        .with_name(&quot;debug_world&quot;)
        .with_world()
        .build(|world: &amp;_| {
            tracing::debug!(&quot;World: {world:?}&quot;);
        });

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schedule-1"><a class="header" href="#schedule-1">Schedule</a></h1>
<p>A schedule allows execution and paralellization of multiple systems.</p>
<p>The systems discussed in the previous chapter can be put into a schedule to
contain the logic and order of execution.</p>
<p>In addition to executing systems one after another, a schedule can automatically
paralellize execution and run multiple systems at the same time using
<a href="https://docs.rs/rayon/latest/rayon/">rayon</a> such that the observable effects
occurr order.</p>
<p>In other words, if two systems have queries which do not access the same
archetype and components, they will run in paralell. If an archetype reads a
value which is written by another system declared before, they will run in
sequence.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let despawn = System::builder()
        .with_name(&quot;delete_outside_world&quot;)
        .with_query(Query::new((entity_ids(), distance())).filter(distance().gt(50.0)))
        .with_cmd_mut()
        .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
            for (id, &amp;dist) in &amp;mut q {
                println!(&quot;Despawning {id} at: {dist}&quot;);
                cmd.despawn(id);
            }
        });

    let debug_world = System::builder()
        .with_name(&quot;debug_world&quot;)
        .with_world()
        .build(|world: &amp;_| {
            tracing::debug!(&quot;World: {world:?}&quot;);
        });


    component! {
        is_static: () =&gt; [ flax::Debuggable ],
    }

    // Spawn 150 static entities, which wont move
    let mut rng = StdRng::seed_from_u64(42);

    for _ in 0..150 {
        let pos = vec2(rng.gen_range(-5.0..5.0), rng.gen_range(-5.0..5.0));
        Entity::builder()
            .set(position(), pos)
            .set_default(distance())
            .set_default(is_static())
            .spawn(&amp;mut world);
    }

    // Since this system will move non static entities out from the origin, they will
    // eventually be despawned
    let move_out = System::builder()
        .with_name(&quot;move_out&quot;)
        .with_query(Query::new(position().as_mut()).filter(is_static().without()))
        .for_each(|pos| {
            let dir = pos.normalize_or_zero();

            *pos += dir;
        });

    // Spawn new entities with a random position each frame
    let spawn = System::builder().with_name(&quot;spawner&quot;).with_cmd_mut().build(
        move |cmd: &amp;mut CommandBuffer| {
            for _ in 0..100 {
                let pos = vec2(rng.gen_range(-10.0..10.0), rng.gen_range(-10.0..10.0));
                println!(&quot;Spawning new entity at: {pos:?}&quot;);
                Entity::builder()
                    .set(position(), pos)
                    .set_default(distance())
                    .spawn_into(cmd);
            }
        },
    );

    let mut frame_count = 0;

    // Count the number of entities in the world and log it
    let count = System::builder()
        .with_name(&quot;count&quot;)
        .with_query(Query::new(()))
        .build(move |mut query: QueryBorrow&lt;()&gt;| {
            let count: usize = query.iter_batched().map(|v| v.len()).sum();
            println!(&quot;[{frame_count}]: {count}&quot;);
            frame_count += 1;
        });

    // Assemble the schedule, takes care of dependency management
    let mut schedule = Schedule::builder()
        .with_system(update_dist)
        .with_system(despawn)
        .with_system(spawn)
        .with_system(move_out)
        .with_system(debug_world)
        .with_system(count)
        .build();

    println!(&quot;{schedule:#?}&quot;);

    for i in 0..20 {
        println!(&quot;Frame: {i}&quot;);
        println!(&quot;Batches: {:#?}&quot;, schedule.batch_info(&amp;world));
        schedule.execute_par(&amp;mut world)?;
    }

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-builder"><a class="header" href="#entity-builder">Entity Builder</a></h1>
<p>The <a href="https://docs.rs/flax/latest/flax/struct.EntityBuilder.struct">EntityBuilder</a>
allows you to incrementally construct an entity by adding components and <em>then</em>
inserting it into the world. This provides both better ergonomics and efficiency
as the entity does not bounce around archetypes.</p>
<p>Additionally, the entity builder allows constructing an entity in the absence of
the world, like a function which only creates the <code>EntityBuilder</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        health: f32 =&gt; [Debuggable],
        position: (f32, f32) =&gt; [Debuggable],
        is_player: () =&gt; [Debuggable],
    }

    let mut world = World::new();

    // Instead of this
    let player = world.spawn();
    world.set(player, health(), 100.0).unwrap();
    world.set(player, position(), (5.0, 2.3)).unwrap();
    world.set(player, is_player(), ()).unwrap();
    world.set(player, name(), &quot;Player&quot;.into()).unwrap();

    tracing::info!(&quot;Player: {:#?}&quot;, world.format_entities(&amp;[player]));
    world.despawn(player).unwrap();

    // Do this
    let player = Entity::builder()
        .set(health(), 100.0)
        .set(position(), (5.0, 2.3))
        .tag(is_player())
        .set(name(), &quot;Player&quot;.into())
        .spawn(&amp;mut world);

    tracing::info!(&quot;Player: {:#?}&quot;, world.format_entities(&amp;[player]));

<span class="boring">}</span></code></pre></pre>
<p>When the entity builder is spawned, the held components are moved out into the
matching archetype in the world.</p>
<p>This means the entity builder is cleared and ready to insert more components.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut builder = Entity::builder();
    let mut rng = StdRng::seed_from_u64(42);

    let enemies = (0..10)
        .map(|i| {
            builder
                .set(health(), rng.gen_range(50..100) as f32)
                .set(
                    position(),
                    (rng.gen_range(-10.0..10.0), rng.gen_range(-10.0..10.0)),
                )
                .set(name(), format!(&quot;Enemy.{i}&quot;))
                .spawn(&amp;mut world)
        })
        .collect_vec();

    tracing::info!(&quot;Enemies: {enemies:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut query = Query::new((name(), position(), is_player().opt(), health()));
    for (name, pos, is_player, health) in &amp;mut query.borrow(&amp;world) {
        tracing::info!(&quot;name: {name}, pos: {pos:?}, player: {is_player:?}, health: {health}&quot;);
    }

    // Or to only get the non players

    {
        let mut query = Query::new((name(), position(), health())).without(is_player());
        info_span!(&quot;enemies&quot;);
        for (name, pos, health) in &amp;mut query.borrow(&amp;world) {
            tracing::info!(&quot;name: {name}, pos: {pos:?}, health: {health}&quot;);
        }
    }

<span class="boring">}</span></code></pre></pre>
<h2 id="batch-spawn"><a class="header" href="#batch-spawn">Batch Spawn</a></h2>
<p>If inserting <strong>many</strong> entities of the same type, it is more efficient to let the world know about
the coming components and insert everything at once.</p>
<p>The batch spawn allows spawning many entities with the same component types at
once by inserting columns of each component type. This is akin to the native
format of the archetype storage and is thus maximally efficient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut trees = BatchSpawn::new(10000);
    trees
        .set(name(), (0..).map(|i| format!(&quot;Tree.{i}&quot;)))
        .expect(&quot;Invalid length&quot;);

    trees
        .set(
            position(),
            (0..).map(|i| {
                let f = i as f32 / 32.0;
                (f.cos() * (1.0 + f / 2.0), f.sin() * (1.0 + f / 2.0))
            }),
        )
        .expect(&quot;Invalid length&quot;);

    let trees = trees.spawn(&amp;mut world);

    tracing::info!(&quot;Trees: {:#?}&quot;, world.format_entities(&amp;trees[0..100]));

<span class="boring">}</span></code></pre></pre>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<p>In the previous chapter, hierarchies were constructed by adding a relation to an
entity to the child entity.</p>
<p>The entity builder allows construction of hierarchies before being spawned into
the world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let id = Entity::builder()
        .set(name(), &quot;parent&quot;.into())
        .attach(
            child_of,
            Entity::builder()
                .set(name(), &quot;child1&quot;.into())
                .attach(child_of, Entity::builder().set(name(), &quot;child1.1&quot;.into())),
        )
        .attach(child_of, Entity::builder().set(name(), &quot;child2&quot;.into()))
        .spawn(&amp;mut world);

    tracing::info!(&quot;Parent: {id}&quot;);

    tracing::info!(&quot;World: {world:#?}&quot;);

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commandbuffer"><a class="header" href="#commandbuffer">CommandBuffer</a></h1>
<p>The commandbuffer allows deferred modification of the world.</p>
<p>This is useful in queries where the world is currently being iterated over, or
in other situations where a mutable reference to the world is not available.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        position: Vec2,
    }

    let mut world = World::new();

    let mut cmd = CommandBuffer::new();

    cmd.spawn(Entity::builder().set(name(), &quot;a&quot;.into()));

    cmd.apply(&amp;mut world)?;

    let id = Query::new(entity_ids())
        .filter(name().eq(&quot;a&quot;))
        .borrow(&amp;world)
        .iter()
        .next()
        .context(&quot;Missing entity&quot;)?;

    cmd.set(id, position(), vec2(32.0, 2.6));
    let id2 = world.spawn();

    cmd.spawn_at(
        id,
        EntityBuilder::new()
            .set(name(), &quot;b&quot;.into())
            .set(position(), vec2(4.6, 8.4)),
    );

    cmd.remove(id2, position());

    cmd.apply(&amp;mut world)?;

    cmd.set(id2, child_of(id), ());

    // Execute this function when the commandbuffer is applied
    cmd.defer(move |w| {
        w.despawn_recursive(id, child_of)?;
        Ok(())
    });

    cmd.apply(&amp;mut world)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-with-schedule"><a class="header" href="#usage-with-schedule">Usage with schedule</a></h2>
<p>A schedule contains a commandbuffer which is available in systems through
<code>.write::&lt;CommandBuffer&gt;()</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        world_matrix: Mat4 =&gt; [Debuggable],
    }

    // Make sure there are always 64 entities in the world
    let mut rng = StdRng::seed_from_u64(42);
    let spawner = System::builder()
        .with_name(&quot;spawn_entities&quot;)
        .with_query(Query::new(()))
        .with_cmd_mut()
        .build(move |mut q: QueryBorrow&lt;()&gt;, cmd: &amp;mut CommandBuffer| {
            let count = q.count();

            for _ in count..64 {
                tracing::info!(&quot;Spawning new entity&quot;);
                cmd.spawn(
                    Entity::builder()
                        .set(name(), &quot;entity&quot;.to_string())
                        .set(position(), rng.gen()),
                );
            }
        });

    // Ensure a world matrix to each entity with a position
    let add_world_matrix = System::builder()
        .with_name(&quot;add_world_matrix&quot;)
        .with_query(Query::new((entity_ids(), position())).without(world_matrix()))
        .with_cmd_mut()
        .build(
            |mut q: QueryBorrow&lt;(EntityIds, Component&lt;Vec2&gt;), _&gt;, cmd: &amp;mut CommandBuffer| {
                for (id, pos) in &amp;mut q {
                    tracing::info!(&quot;Adding world matrix to {id}&quot;);
                    cmd.set(id, world_matrix(), Mat4::from_translation(pos.extend(0.0)));
                }
            },
        );

    // Update the world matrix if position changes
    let update_world_matrix = System::builder()
        .with_name(&quot;update_world_matrix&quot;)
        .with_query(
            Query::new((entity_ids(), position(), world_matrix().as_mut()))
                .filter(position().modified()),
        )
        .for_each(|(id, pos, ltw)| {
            tracing::info!(&quot;Updating world matrix for {id}&quot;);
            *ltw = Mat4::from_translation(pos.extend(0.0));
        });

    let mut schedule = Schedule::builder()
        .with_system(spawner)
        .flush()
        .with_system(add_world_matrix)
        .flush()
        .with_system(update_world_matrix)
        .build();

    schedule
        .execute_par(&amp;mut world)
        .context(&quot;Failed to run schedule&quot;)?;

<span class="boring">}</span></code></pre></pre>
<p>The commandbuffer will be applied at the end of the schedule automatically.</p>
<p><code>flush</code> can be used to apply the commandbuffer to make the modifications visible
to the following systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relations"><a class="header" href="#relations">Relations</a></h1>
<p>A relation is a component which <em>links</em> to another <code>Entity</code>, similar to a foreign key in a database. This can be used to construct different kinds of graphs and trees inside the ECS.</p>
<p>The links between entities are managed by the ECS itself and will always be valid, see <a href="fundamentals/relations.html#lifetime">Lifetime</a>.</p>
<p>The linked entity is referred to as the <code>target</code> of a relation, while the entity the component is attached to is called the <code>subject</code>.</p>
<p>This allows forming hierarchies such as <em>parent-child</em> relations for transforms and UI, as well as arbitrary graphs.</p>
<p>See the <a href="https://docs.rs/flax/latest/flax/components/fn.child_of.html"><code>child_of</code></a> relation for an example of a parent-child relation which uses the parent entity as the relation's <em>target</em>.</p>
<p>Relations are most easily declared using the
<a href="https://docs.rs/flax/latest/flax/macro.component.html">component</a> macro, but can be constructed dynamically as well. See <a href="fundamentals/../diving_deeper/dynamic_components.html">dynamic_components</a></p>
<p>For example, declaring a child relationship that connects to a parent can be done like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        child_of(id): (),
    }

    let parent = Entity::builder()
        .set(name(), &quot;Parent&quot;.into())
        .spawn(&amp;mut world);

    let child1 = Entity::builder()
        .set(name(), &quot;Child1&quot;.into())
        .set_default(child_of(parent))
        .spawn(&amp;mut world);

    let child2 = Entity::builder()
        .set(name(), &quot;Child2&quot;.into())
        .set_default(child_of(parent))
        .spawn(&amp;mut world);
<span class="boring">}</span></code></pre></pre>
<p>The parameter to the component function determines the target entity of the relation.</p>
<p>Since the value of the relation in this case is <code>()</code>, <code>set_default</code> can be used as a shorthand over <code>set</code></p>
<p>Two relations of the same type but with different <em>targets</em> behave like two separate components and will not interfere. This allows having many-to-many relationships between entities, if so desired.</p>
<p>This allows constructing many different kinds of graphs inside the ECS.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let parent2 = Entity::builder()
        .set(name(), &quot;Parent2&quot;.into())
        .spawn(&amp;mut world);

    world.set(child1, child_of(parent2), ())?;

    tracing::info!(&quot;World: {world:#?}&quot;);

    // Give child1 yet one more parent
    world.set(child1, child_of(parent2), ())?;

    tracing::info!(
        &quot;Connections from child1({child1}): {:?}&quot;,
        Query::new(relations_like(child_of))
            .borrow(&amp;world)
            .get(child1)?
            .collect_vec()
    );

<span class="boring">}</span></code></pre></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>Since relations are normal components, they can be used in a query as normal, or
used to exclude components.</p>
<p>See the <a href="fundamentals/../query/graphs.html">Graphs</a> chapter in queries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Mathes a relation exactly
    let children_of_parent: Vec&lt;Entity&gt; = Query::new(entity_ids())
        .with(child_of(parent))
        .collect_vec(&amp;world);

    tracing::info!(&quot;Children: {children_of_parent:?}&quot;);

    // Matches a relation with any parent
    let all_children: Vec&lt;Entity&gt; = Query::new(entity_ids())
        .filter(child_of.with_relation())
        .collect_vec(&amp;world);

    tracing::info!(&quot;Children: {all_children:?}&quot;);

    let roots = Query::new(entity_ids())
        .filter(child_of.without_relation())
        .collect_vec(&amp;world);

    tracing::info!(&quot;Roots: {roots:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="associated-values"><a class="header" href="#associated-values">Associated values</a></h2>
<p>In addition to linking between entities, a relation can also store additional data just like a component. This can be used to create weighted graphs or storing other additional information such as physical joint parameters.</p>
<p>Since relations behave like separate components, each value on a relation is specific to that link, and as such saves you the hassle of managing a separate list of values for each connection on an entity.</p>
<p>The following shows a more complete example of how to traverse and calculate the forces between entities connected via springs using hook's law.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Spring {
        strength: f32,
        length: f32,
    }

    impl Spring {
        fn new(strength: f32, length: f32) -&gt; Self {
            Self { strength, length }
        }
    }
    component! {
        spring_joint(id): Spring,
        position: Vec2,
    }

    let id1 = Entity::builder()
        .set(name(), &quot;a&quot;.into())
        .set(position(), vec2(1.0, 4.0))
        .spawn(&amp;mut world);

    // Connect id2 to id1 with a spring of strength 2.0
    let id2 = Entity::builder()
        .set(name(), &quot;b&quot;.into())
        .set(spring_joint(id1), Spring::new(2.0, 1.0))
        .set(position(), vec2(2.0, 0.0))
        .spawn(&amp;mut world);

    let _id3 = Entity::builder()
        .set(name(), &quot;c&quot;.into())
        .set(spring_joint(id1), Spring::new(2.0, 3.0))
        .set(position(), vec2(2.0, 3.0))
        .spawn(&amp;mut world);

    let _id4 = Entity::builder()
        .set(name(), &quot;d&quot;.into())
        .set(spring_joint(id2), Spring::new(5.0, 0.5))
        .set(position(), vec2(1.0, 0.0))
        .spawn(&amp;mut world);

    let mut query = Query::new((entity_ids(), name().cloned(), position()))
        .with_strategy(Dfs::new(spring_joint));

    query
        .borrow(&amp;world)
        .traverse(&amp;None, |(id, name, &amp;pos), strength, parent| {
            if let (Some(spring), Some((parent_name, parent_pos))) = (strength, parent) {
                let distance = pos.distance(*parent_pos) - spring.length;
                let force = distance * spring.strength;
                tracing::info!(&quot;spring acting with {force:.1}N between {parent_name} and {name}&quot;);
            } else {
                tracing::info!(%id, name, &quot;root&quot;);
            }

            Some((name, pos))
        });
<span class="boring">}</span></code></pre></pre>
<h1 id="exclusive-relations"><a class="header" href="#exclusive-relations">Exclusive relations</a></h1>
<p>Relations can be declared as exclusive, which means that only one relation of that type can exist on an entity at a time. This is useful for cases where you want to have a single parent or outgoing connection. </p>
<p><strong>Note</strong>: This does not prevent multiple entities from referencing the same entity, but rather an entity referencing multiple entities.</p>
<p>When a new relation is added to an entity, any existing relation of the same type will be removed.</p>
<p>This is the case for the included <a href="https://docs.rs/flax/latest/flax/components/fn.child_of.html"><code>child_of</code></a> relation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        child_of(parent): () =&gt; [ Exclusive ],
    }

    let id1 = Entity::builder().spawn(&amp;mut world);
    let id2 = Entity::builder().spawn(&amp;mut world);

    let id3 = Entity::builder()
        .set_default(child_of(id1))
        .spawn(&amp;mut world);

    let entity = world.entity_mut(id3).unwrap();

    tracing::info!(
        &quot;relations of {id3}: {:?}&quot;,
        entity.relations(child_of).map(|v| v.0).collect_vec()
    );

    world.set(id3, child_of(id2), ()).unwrap();

    let entity = world.entity_mut(id3).unwrap();
    tracing::info!(
        &quot;relations of {id3}: {:?}&quot;,
        entity.relations(child_of).map(|v| v.0).collect_vec()
    );
<span class="boring">}</span></code></pre></pre>
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<p>Relations are managed by the ECS and will automatically be cleaned up. When an entity is despawned all relations which reference it will be removed from the ECS. As such, a relation will never point to an invalid entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    tracing::info!(
        &quot;has relation to: {parent2}: {}&quot;,
        world.has(child1, child_of(parent2))
    );

    world.despawn(parent2)?;

    tracing::info!(
        &quot;has relation to: {parent2}: {}&quot;,
        world.has(child1, child_of(parent2))
    );

    tracing::info!(&quot;World: {world:#?}&quot;);
    world.despawn_recursive(parent, child_of)?;

    tracing::info!(&quot;World: {world:#?}&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-metadata"><a class="header" href="#component-metadata">Component metadata</a></h1>
<p>The keen eyed of you may have noticed that <code>ComponentId</code> is the same as
<code>Entity</code>.</p>
<p>This is a design choice; a component is also an entity, and as such, exists in
the world.</p>
<p>This brings some interesting possibilities which are not possible in other ECS
systems, mainly: components can have components.</p>
<p>This allows the components to be queried just as they were normal entities, which
allows reflection.</p>
<p>For example, a component can itself have a component which knows how to
<code>Debug::fmt</code> the component value, another component could be used to serialize a
value.</p>
<p>While components could be added to components through the conventional
[<code>World::set</code>] syntax, it can quickly become a spaghetti of <code>init</code> functions for
each library to add the required components, or metadata to the exported
components.</p>
<p>This is where the <a href="https://docs.rs/flax/latest/flax/macro.component.html">component</a> macro comes into play. The component function acquires a globally free <code>Entity</code> and assigns that to the strongly typed component.
When the component is first inserted into the world it can insert so called <em>metadata</em> to the component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// An entity's health.
        /// Provides the Debug bundle, which adds the `debug_visitor` component.
        health: f32 =&gt; [ flax::Debuggable ],
    }

    // After adding the component, the associate metadata of the `health`
    // component is added to the world.
    world.set(id, health(), 100.0)?;

    let component_name = world.get(health().id(), name())?;
    println!(&quot;The name of the component is {component_name:?}&quot;);

    // Print the state of the world
    println!(&quot;World: {world:#?}&quot;);
    // Prints:
    //
    // World: {
    //     1v2: {},
    //     2v1: {},
    //     3v1: {},
    //     4v1: {},
    //     5v1: {},
    //     6v1: {},
    //     7v1: {},
    //     8v1: {},
    //     9v1: {},
    //     10v1: {},
    //     11v1: {
    //         &quot;position&quot;: _,
    //         &quot;health&quot;: 100.0,
    //     },
    // }

<span class="boring">}</span></code></pre></pre>
<p>The</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>component: type =&gt; [ Meta, Meta, Meta ]
<span class="boring">}</span></code></pre></pre>
<p>syntax is used to add metadata to the component.</p>
<p>The <code>component</code> component, and the <code>name</code> component is always present.</p>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>If a component has the
<a href="https://docs.rs/flax/latest/flax/struct.Debug.html">flax::Debuggable</a> component, the
component and value for each entity will be present when debug formatting the
world.</p>
<h2 id="name"><a class="header" href="#name">Name</a></h2>
<p>Every component has a <code>name</code>, which is the same as the declaration.</p>
<h2 id="custom-metadata"><a class="header" href="#custom-metadata">Custom metadata</a></h2>
<p>Custom metadata can be added to a component by creating a struct which
implements <a href="https://docs.rs/flax/latest/flax/trait.MetaData.html">MetaData</a>,
which is responsible of adding the appropriate components.</p>
<p><strong>Note</strong>: Do not use conditional compilation for these structs as this leaks the
<code>cfg</code> directives to any uses of the metadata in the <code>component</code> macro. Instead,
conditionally add, or do not add, the component in the <code>attach</code> method.</p>
<p>A common example of this is <code>serde</code>, prefer to not add the <code>serializer</code>
component and still define <code>Serialize</code> and making it no-op when <code>serde</code> is not
enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries-1"><a class="header" href="#queries-1">Queries</a></h1>
<p>A query is the most useful tool in your ECS toolbox, and has many use cases.</p>
<p>This chapter explores the available methods and uses for queries</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>At its simplest form, a query is composed of a <a href="https://docs.rs/flax/latest/flax/fetch/trait.Fetch.html">Fetch</a> which specify the group of components to select. The query will visit the subset of entities in the world which have the specified components, and return their values.</p>
<p>In order to execute a query, it has borrow the relevant data from the world. This returns a <a href="https://docs.rs/flax/latest/flax/struct.QueryBorrow">QueryBorrow</a> which can then be iterated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new(name());

        for name in &amp;mut query.borrow(&amp;world) {
            tracing::info!(&quot;Entity: {name:?}&quot;);
        }

<span class="boring">}</span></code></pre></pre>
<p>A <code>tuple</code> can be used which will yield the entities with all the specified components, such as all entities with a <code>name</code>, <code>position</code>, and <code>health</code>; which excludes all the pretty rocks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new((name(), position(), health()));

        for (name, pos, health) in &amp;mut query.borrow(&amp;world) {
            tracing::info!(&quot;Entity: {name:?} pos: {pos}, health: {health}&quot;);
        }

<span class="boring">}</span></code></pre></pre>
<h2 id="mutation"><a class="header" href="#mutation">Mutation</a></h2>
<p><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.as_mut"><code>.as_mut</code></a> will transform a component into yielding mutable references.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        fn lightning_strike(world: &amp;World, rng: &amp;mut StdRng) {
            let mut query = Query::new(health().as_mut());
            for h in &amp;mut query.borrow(world) {
                // &amp;mut f32
                *h -= rng.gen_range(10.0..20.0);
            }
        }

        lightning_strike(&amp;world, &amp;mut rng);

<span class="boring">}</span></code></pre></pre>
<h2 id="optional"><a class="header" href="#optional">Optional</a></h2>
<p><a href="https://docs.rs/flax/latest/flax/fetch/trait.FetchExt.html#method.opt"><code>.opt</code></a> makes a part of the fetch optional. This can be applied to a single component, or to the tuple or nested tuples as a whole.</p>
<p>In addition, <a href="https://docs.rs/flax/latest/flax/fetch/trait.FetchExt.html#method.opt"><code>.opt_or</code></a>, and <a href="https://docs.rs/flax/latest/flax/fetch/trait.FetchExt.html#method.opt"><code>.opt_or_default</code></a> allows specifying a fallback if the entity does not have the component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new((name(), position(), health().opt()));

        (&amp;mut query.borrow(&amp;world)).into_iter().for_each(
            |(name, pos, health): (&amp;String, &amp;Vec3, Option&lt;&amp;f32&gt;)| {
                tracing::info!(&quot;Entity: {name:?} pos: {pos}, health: {health:?}&quot;);
            },
        );

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters-1"><a class="header" href="#filters-1">Filters</a></h1>
<p>A filter allows further specifying, and consequently narrowing, the subset of entities to visit.</p>
<p>For instance, a filter can allow querying the set of entities which have a specified component, or the set of entities which <em>do not</em> have the specified components, among others.</p>
<h2 id="with-and-without"><a class="header" href="#with-and-without">With and Without</a></h2>
<p>Allows including or excluding a set of entities from the query depending on their components.</p>
<p>Combined with tag like components, a query which only yields the player can be achieved.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new((name(), health())).filter(player().with());

        let mut borrow = query.borrow(&amp;world);

        if let Some((name, health)) = borrow.iter().next() {
            tracing::info!(&quot;The player {name} is alive and well at {health} health&quot;);
        } else {
            tracing::info!(&quot;The player seems to have perished&quot;);
        }

<span class="boring">}</span></code></pre></pre>
<p>... or everything that isn't a player, that of course still has the required <code>name</code> and <code>health</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new((name(), health())).filter(player().without());

        for (name, health) in &amp;mut query.borrow(&amp;world) {
            tracing::info!(&quot;Npc: {name} at {health} health&quot;);
        }

<span class="boring">}</span></code></pre></pre>
<h2 id="combinators"><a class="header" href="#combinators">Combinators</a></h2>
<p>Several filters can be combined using <code>&amp;</code> and <code>|</code>, as well as <code>!</code>.</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>It is also possible to filter on the value of a component.</p>
<p>This is different from using <code>filter</code> on the iterator, as the comparison will filter and select <em>before</em> the query traverses the entities, which means it avoids unnecessary modification events for mutable queries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new(name()).filter(health().without() | health().ge(35.0));
        for name in &amp;mut query.borrow(&amp;world) {
            tracing::info!(&quot;{name} is still standing strong&quot;);
        }

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h1>
<p>Flax tracks when a component is added, mutably accessed, or removed.</p>
<p>A query allows filtering the entities based on a change event since it last ran.</p>
<ul>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.modified"><code>modified</code></a> filter mutated or new components</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.added"><code>added</code></a> only new components</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.removed"><code>removed</code></a> filter recently removed components.</li>
</ul>
<p>The modified filter is best used for queries which calculate or update a value
based on one or more components, or in other ways react to a changed value.</p>
<p>A change filter can be added to a single component, or to a tuple of components. Applying a <code>.modified()</code> transform on a tuple will create a query which yields if <em>any</em> of the constituents were modified.</p>
<p>The following example creates a system which prints the updated health values
for each entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let query = Query::new((name(), health().modified()));

    let health_changes = System::builder()
        .with_query(query)
        .build(|mut query: QueryBorrow&lt;_&gt;| {
            info_span!(&quot;health_changes&quot;);
            for (name, health) in &amp;mut query {
                tracing::info!(&quot;{name:?}: is now at {health} health&quot;);
            }
        });

<span class="boring">}</span></code></pre></pre>
<h1 id="combining-filters"><a class="header" href="#combining-filters">Combining filters</a></h1>
<p>Change filters can be combined with other filters, which leads to queries needing to perform even even less work.</p>
<p>The following example creates a query which removes despawns entities when their
health becomes <code>0</code>. Noteworthy in particular, is that this system can run in
parallel with the previously discussed system, since they do not overlap in
mutable access.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let query = Query::new((name().opt(), entity_ids(), player().satisfied()))
        .filter(health().le(0.0).modified());

    let cleanup = System::builder()
        .with_name(&quot;cleanup&quot;)
        .with_query(query)
        .with_cmd_mut()
        .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
            for (name, id, is_player) in &amp;mut q {
                if is_player {
                    tracing::info!(&quot;Player died&quot;);
                }
                tracing::info!(name, is_player, &quot;Despawning {id}&quot;);
                cmd.despawn(id);
            }
        });

<span class="boring">}</span></code></pre></pre>
<h1 id="bringing-it-all-together"><a class="header" href="#bringing-it-all-together">Bringing it all together</a></h1>
<p>In order for the health monitoring and cleanup systems to be effective, there
needs to be something to modify the health of entities.</p>
<p>Such as a random damage system, and a poison status effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let player_id = Entity::builder()
        .set(name(), &quot;player&quot;.into())
        .set(health(), 100.0)
        .set_default(player())
        .spawn(&amp;mut world);

    let enemies = (0..10)
        .map(|i| {
            Entity::builder()
                .set(name(), format!(&quot;enemy.{i}&quot;))
                .set(health(), 50.0)
                .spawn(&amp;mut world)
        })
        .collect_vec();

    let all = enemies.iter().copied().chain([player_id]).collect_vec();

    let mut rng = StdRng::from_entropy();

    all.choose_multiple(&amp;mut rng, all.len() / 5)
        .for_each(|&amp;id| {
            world.set(id, poison(), 10.0).unwrap();
        });

    let damage_random = System::builder()
        .with_world_mut()
        .build(move |world: &amp;mut World| {
            let count = rng.gen_range(0..enemies.len());
            let targets = all.choose_multiple(&amp;mut rng, count);
            for &amp;enemy in targets {
                if let Ok(mut health) = world.get_mut(enemy, health()) {
                    *health -= 1.0;
                }
            }
        });

    let update_poison = System::builder()
        .with_query(Query::new((name().opt(), health().as_mut(), poison())))
        .for_each(|(name, health, poison)| {
            *health -= poison;
            tracing::info!(&quot;{name:?} suffered {poison} in poison damage&quot;);
        });

<span class="boring">}</span></code></pre></pre>
<p>Using a schedule allows for easy parallelization and execution of the systems, but
is not a requirement for change detection.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut schedule = Schedule::new()
        .with_system(damage_random)
        .with_system(update_poison)
        .with_system(health_changes)
        .flush()
        .with_system(cleanup)
        .flush();

    while world.is_alive(player_id) {
        schedule
            .execute_par(&amp;mut world)
            .expect(&quot;Failed to run schedule&quot;);

        sleep(Duration::from_millis(1000));
    }

<span class="boring">}</span></code></pre></pre>
<p>See the full example <a href="https://github.com/ten3roberts/flax/blob/main/examples/guide/change_detection.rs">here</a></p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>Each <code>ChangeEvent</code> consists of a subslice of adjacent entities in the same
archetype, the change type, and when the change occurred.</p>
<p>Two change events where the entities are adjacent will be joined into a single
one will be joined. This means the change list is always rather small compared
to the number of changing entities (especially compared to using a <code>HashSet</code>).</p>
<p>The following example combines optional queries with change detection to create
a small physic calculation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-query"><a class="header" href="#entity-query">Entity Query</a></h1>
<p>By default, a query will iterate all entities which match the archetype.</p>
<p>However, the query strategy can be changed to only return a single entity, which is useful for queries over a resource entity or player.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        window_width: f32,
        window_height: f32,
        allow_vsync: bool,

        /// A static entity, which is always alive
        resources,
    }

    Entity::builder()
        .set(window_width(), 800.0)
        .set(window_height(), 600.0)
        .set(allow_vsync(), false)
        // Since `resources` is static, it is not required to spawn it
        .append_to(&amp;mut world, resources())
        .unwrap();

    let mut query = Query::new((window_width(), window_height(), allow_vsync()))
        // Change the query strategy to only iterate the `resources` entity
        .entity(resources());

    let mut borrow = query.borrow(&amp;world);
    let (width, height, vsync) = borrow.get().unwrap();
    println!(&quot;width: {width} height: {height}, vsync: {vsync}&quot;);

<span class="boring">}</span></code></pre></pre>
<p>In addition, an entity query can be used in a system</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut window_system = System::builder()
        .with_query(query)
        .build(|mut q: EntityBorrow&lt;_&gt;| {
            if let Ok((width, height, allow_vsync)) = q.get() {
                println!(
                    &quot;Config changed width: {width}, height: {height}, allow_vsync: {allow_vsync}&quot;
                );
            } else {
                println!(&quot;No config change&quot;);
            }
        });

    window_system.run(&amp;mut world);
    window_system.run(&amp;mut world);
    world.set(resources(), window_height(), 720.0)?;
    window_system.run(&amp;mut world);


<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs"><a class="header" href="#graphs">Graphs</a></h1>
<p>The relation system allows creating Entity hierarchies and graphs.</p>
<p>These graphs can be traversed in different ways through the use of a <a href="https://docs.rs/flax/latest/flax/struct.Query.html">Query</a>.</p>
<p>The default <code>child_of</code> relation provides a <em>mutually exclusive</em> parent-child relation, which is perfect for transform hierarchies or trees, and is trivial to construct using the <a href="https://docs.rs/flax/latest/flax/struct.EntityBuilder.html#method.attach">EntityBuilder::attach</a> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let root = Entity::builder()
        .set(name(), &quot;root&quot;.into())
        .attach(
            child_of,
            Entity::builder().set(name(), &quot;root.child.1&quot;.into()).attach(
                child_of,
                Entity::builder().set(name(), &quot;root.child.1.1&quot;.into()),
            ),
        )
        .attach(
            child_of,
            Entity::builder().set(name(), &quot;root.child.2&quot;.into()),
        )
        .attach(
            child_of,
            Entity::builder().set(name(), &quot;root.child.3&quot;.into()),
        )
        .spawn(&amp;mut world);

<span class="boring">}</span></code></pre></pre>
<p>Likewise, <a href="https://docs.rs/flax/latest/flax/entity/struct.EntityBuilder.html#method.attach_with"><code>attach_with</code></a> can be used for stateful relations</p>
<h2 id="depth-first-iteration"><a class="header" href="#depth-first-iteration">Depth First Iteration</a></h2>
<p><a href="https://docs.rs/flax/latest/flax/query/struct.Dfs.html">Dfs</a> allows traversing hierarchies in depth-first order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>        let mut query = Query::new((entity_ids(), name())).with_strategy(Dfs::new(child_of));

        tracing::info!(&quot;Dfs:&quot;);
        for (id, name) in query.borrow(&amp;world).iter() {
            tracing::info!(?id, ?name);
        }

<span class="boring">}</span></code></pre></pre>
<h3 id="traversal"><a class="header" href="#traversal">Traversal</a></h3>
<p>For modifying a graph through a value which is passed through the parents, such as updating a UI layout, there is <a href="https://docs.rs/flax/latest/flax/query/struct.Dfs.html#method.traverse">Dfs::traverse</a> which provides an easy recursion based visiting, which can for example be used for updating transform hierarchies.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let update_world_position = System::builder()
        .with_query(
            Query::new((world_position().as_mut(), position())).with_strategy(Dfs::new(child_of)),
        )
        .build(
            |mut query: DfsBorrow&lt;(Mutable&lt;Vec3&gt;, Component&lt;Vec3&gt;), All, ()&gt;| {
                query.traverse(&amp;Vec3::ZERO, |(world_pos, &amp;pos), _, &amp;parent_pos| {
                    *world_pos = pos + parent_pos;
                    *world_pos
                });
            },
        );

    let mut buf = String::new();
    let print_hierarchy = System::builder()
        .with_query(
            Query::new((name(), position(), world_position())).with_strategy(Dfs::new(child_of)),
        )
        .build(move |mut query: DfsBorrow&lt;_, _, _&gt;| {
            query.traverse(&amp;0usize, |(name, pos, world_pos), _, depth| {
                let indent = depth * 4;
                writeln!(
                    buf,
                    &quot;{:indent$}{name}: {pos} {world_pos}&quot;,
                    &quot;&quot;,
                    indent = indent,
                )
                .unwrap();
                depth + 1
            });

            tracing::info!(&quot;{buf}&quot;);
        });

    let mut schedule = Schedule::new()
        .with_system(update_world_position)
        .with_system(print_hierarchy);

    schedule.execute_seq(&amp;mut world).unwrap();

<span class="boring">}</span></code></pre></pre>
<p>See: <a href="https://github.com/ten3roberts/flax/blob/main/examples/query/transform.rs">transform</a></p>
<h2 id="topological-iteration"><a class="header" href="#topological-iteration">Topological Iteration</a></h2>
<p>In addition to <em>depth first</em> traversal, queries offer iteration in topological ordering through <a href="https://docs.rs/flax/latest/flax/query/struct.Topo.html">Topo</a>.</p>
<p>Topological ordering is less constrained as it only ensures that each node's parents are visited before the children, but not that the children are visited immediately after the parent.</p>
<p>More specifically, each <em>node</em> is visited in the ordered of their <em>maximum recursion depth</em>. I.e, first all roots are visited, then all children, then all <em>2nd</em> level children and so on.</p>
<p>This allows far greater cache locality and is more similar in memory access patterns to the non-relation aware <a href="https://docs.rs/flax/latest/flax/query/struct.Planar.html">Planar</a> strategy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diving-deeper"><a class="header" href="#diving-deeper">Diving deeper</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-query"><a class="header" href="#advanced-query">Advanced query</a></h1>
<p>A query is a combination of a
<a href="https://docs.rs/flax/latest/flax/traits.Fetch"><code>Fetch</code></a> and a
<a href="https://docs.rs/flax/latest/flax/traits.Filter"><code>Filter</code></a> in unison with a state.</p>
<p>The most common kind of <code>Fetch</code> is the component and the tuple fetch. The tuple
combines multiple fetches into a single one.</p>
<p>A tuple of components, or any other <code>Fetch</code> will only yield entities which match
the full tuple, I.e;</p>
<h2 id="optional-query"><a class="header" href="#optional-query">Optional query</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    // Entities with mass
    (0..10).for_each(|i| {
        builder
            .set(name(), format!(&quot;Entity.{i}&quot;))
            .set(position(), rng.gen::&lt;Vec3&gt;() * 10.0)
            .set(velocity(), rng.gen())
            .set(mass(), rng.gen_range(10..30) as f32)
            .spawn(&amp;mut world);
    });

    // Entities without mass
    (0..100).for_each(|i| {
        builder
            .set(name(), format!(&quot;Entity.{i}&quot;))
            .set(position(), rng.gen::&lt;Vec3&gt;() * 0.5)
            .set(velocity(), rng.gen())
            .spawn(&amp;mut world);
    });

    // Since this query accessed `position`, `velocity` **and** `mass` only the
    // first group of entities will be matched
    for (pos, vel, mass) in &amp;mut Query::new((position(), velocity(), mass())).borrow(&amp;world) {
        tracing::debug!(&quot;pos: {pos}, vel: {vel}, mass: {mass}&quot;);
    }

<span class="boring">}</span></code></pre></pre>
<p>Will only yield entities which have both position and velocity.</p>
<p>By adding <code>.opt()</code> to any fetch, you convert it to an <code>Option&lt;T&gt;</code> where <code>T</code> is
the value yielded by the underlying fetch</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    // Use an optional fetch to yield an `Option&lt;T&gt;`, works for any query
    for (pos, vel, mass) in &amp;mut Query::new((position(), velocity(), mass().opt())).borrow(&amp;world) {
        if mass.is_some() {
            tracing::debug!(&quot;Has mass&quot;);
        }
        tracing::debug!(&quot;pos: {pos}, vel: {vel}, mass: {mass:?}&quot;);
    }

<span class="boring">}</span></code></pre></pre>
<p>However, it can still be cumbersome to deal with the option, especially since
components yield references, which can not be combined with
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a></p>
<p>The <a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or_default"><code>opt_or_default</code></a> combinator can be used, or <a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or"><code>opt_or</code></a> to provide your custom value if the entity does not have the specified component.</p>
<p>There only work for fetches which return a shared reference, as the provided
default is also returned by reference. For when there is an owned value, consider using the builting <code>Option::unwrap_or_default</code>.</p>
<p>This combinator is useful when writing systems which may need to operate on entities which lack some components, such as physics where the entity may not have a rotation.</p>
<h2 id="change-detection-1"><a class="header" href="#change-detection-1">Change detection</a></h2>
<p>Every time a component is modified, either through <a href="https://docs.rs/flax/latest/flax/struct.World#method.get_mut"><code>World::get_mut</code></a>, or a query, a <code>Modified</code> event is added to the affected entities.</p>
<p>Similarly, <code>set</code> when the component did not previously exist, and new entities will create an <code>Added</code> event.</p>
<p><code>Removal</code> events are created by
<a href="https://docs.rs/flax/latest/flax/struct.World#method.remove"><code>World::remove</code></a>.</p>
<p>The following example makes use of optional combinators and change detection to
handle a 3d world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        rotation: Quat,
        scale: Vec3,
        world_matrix: Mat4 =&gt; [Debuggable],
    }

    let create_world_matrix = System::builder()
        .with_name(&quot;add_world_matrix&quot;)
        .with_query(
            Query::new(entity_ids())
                .with(position())
                .without(world_matrix()),
        )
        .with_cmd_mut()
        .build(
            |mut query: QueryBorrow&lt;EntityIds, _&gt;, cmd: &amp;mut CommandBuffer| {
                for id in &amp;mut query {
                    tracing::info!(&quot;Adding world matrix to {id}&quot;);
                    cmd.set(id, world_matrix(), Mat4::IDENTITY);
                }
            },
        );

    let update_world_matrix = System::builder()
        .with_name(&quot;update_world_matrix&quot;)
        .with_query(
            Query::new((
                entity_ids(),
                world_matrix().as_mut(),
                position(),
                rotation().opt_or_default(),
                scale().opt_or(Vec3::ONE),
            ))
            .filter(position().modified() | rotation().modified() | scale().modified()),
        )
        .for_each(|(id, world_matrix, pos, rot, scale)| {
            tracing::info!(&quot;Updating world matrix for: {id} {pos} {rot} {scale}&quot;);
            *world_matrix = Mat4::from_scale_rotation_translation(*scale, *rot, *pos);
        });

    let mut schedule = Schedule::builder()
        .with_system(create_world_matrix)
        .flush()
        .with_system(update_world_matrix)
        .build();

    let all_ids = Query::new(entity_ids()).borrow(&amp;world).iter().collect_vec();

    tracing::info!(&quot;Schedule: {schedule:#?}&quot;);

    for _ in 0..10 {
        schedule
            .execute_par(&amp;mut world)
            .expect(&quot;Failed to execute schedule&quot;);

        for _ in 0..32 {
            let id = *all_ids.choose(&amp;mut rng).expect(&quot;no ids&quot;);
            let mut pos = world.get_mut(id, position())?;
            // Move a bit away from origin
            let dir = pos.normalize();
            *pos += dir * rng.gen::&lt;f32&gt;();
            drop(pos);

            let mut scale = world.entry(id, scale())?.or_insert(Vec3::ONE);
            *scale *= 1.1;
        }

        sleep(Duration::from_secs(1))
    }

    tracing::info!(&quot;World: {world:#?}&quot;);

<span class="boring">}</span></code></pre></pre>
<h3 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation details</a></h3>
<pre><code>Each `ChangeEvent` consists of a subslice of adjacent entities in the same
archetype, the change type, and when the change occurred.

Two change events where the entities are adjacent will be joined into a single
one will be joined. This means the change list is always rather small compared
to the number of changing entities (especially compared to using a `HashSet`).

The following example combines optional queries with change detection to create
a small physic calculation.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-components"><a class="header" href="#dynamic-components">Dynamic components</a></h1>
<p>A component is nothing more than a type safe entity id.</p>
<p>The <a href="https://docs.rs/flax/latest/flax/macro.component.html">component</a> uses a
lazily acquired entity. It does not require the world since the entity is
spawned in the <code>STATIC</code> global namespace which is shared across all worlds.</p>
<p>It is entirely possible to create a component at runtime for e.g; a local system.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    registry().with(HierarchicalLayer::default()).init();

    let mut world = World::new();

    let position: Component&lt;Vec2&gt; = world.spawn_component(&quot;position&quot;, |desc| {
        let mut buf = ComponentBuffer::new();
        &lt;Debug as MetaData&lt;Vec2&gt;&gt;::attach(desc, &amp;mut buf);
        buf
    });

    let id = Entity::builder()
        .set(position, vec2(1.0, 6.4))
        .spawn(&amp;mut world);

    tracing::info!(&quot;world: {world:#?}&quot;);

    // When `position` is despawned, it is removed from all entities.
    // This ensured that dead components never exist
    world.despawn(position.id())?;

    tracing::info!(&quot;world: {world:#?}&quot;);

    world.despawn(id)?;
<span class="boring">}</span></code></pre></pre>
<p>The <code>meta</code> allows the user to provide a function to attach extra components to
the entity. This is used by the <code>=&gt; [ty, ty]</code> syntax for the <code>component</code> macro.</p>
<p>The world will automatically manage the lifetime of the component to ensure that
no entity has invalid components attached to it.</p>
<h2 id="relations-1"><a class="header" href="#relations-1">Relations</a></h2>
<p>As a component is just a normal entity you can add an entity to another entity.
Such as adding a parent entity to the children entities.</p>
<p>However, while this method allows quick and easy entity hierarchies, there is no
notion of what the entity represents, and no way to distinguish it from another
component.</p>
<p>This is where component parameterization comes to play.</p>
<p>An entity is <code>64</code> bits in size, sufficient for holding the <code>kind</code>, <code>index</code>, and
<code>generation</code>.</p>
<p>However, since the world manages the lifetime of the component, the generation
of <code>32</code> bits is freed up, which allows other data to be stored, such as another
entity id.</p>
<p>This allows the upper bits of a component(<em>entity</em>) id to contain another
entity as the generation is not needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    #[derive(Debug, Clone)]
    struct RelationData {
        // This allows you to add extra data to the child in the relation
        distance: f32,
    }

    let child_of = world.spawn_relation::&lt;RelationData&gt;(&quot;child_of&quot;, |desc| {
        let mut buf = ComponentBuffer::new();
        &lt;Debug as MetaData&lt;RelationData&gt;&gt;::attach(desc, &amp;mut buf);
        buf
    });

    let parent = world.spawn();

    let child = Entity::builder()
        .set(child_of(parent), RelationData { distance: 1.0 })
        .spawn(&amp;mut world);

    let data = world.get(child, child_of(parent))?;

    tracing::info!(&quot;Relation distance: {:?}&quot;, data.distance);

    drop(data);

    world.despawn(parent)?;
    assert!(world.get(child, child_of(parent)).is_err());

<span class="boring">}</span></code></pre></pre>
<p>When despawning either the relation component or target entity, the &quot;parent&quot;,
the component is removed from all entities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and deserialization</a></h1>
<p>While the built in reflection system could be used for serialization, similar
to <code>Debug</code>, deserialization can not. This is because the lazy registration of
components mean that the world may not know of the componenets deserialization
upfront, especially since deserialization yields a new world.</p>
<p>In addition, having serialization be <em>implicit</em> may lead to components not being
serialized when they are expected to, or components which should not be
serialized to be written to disk, such as local state. As such, it leads to
unexpected, undesirable, or downright insecure behavior.</p>
<p>A similar story is to be found for <em>deserialization</em>, where program behaviour
can be intrusively modified due to anything being able to be deserialized and
put into the world.</p>
<p>As such [de]serialization is explicit and requires registering a subset of
components.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        position: Vec3 =&gt; [Debuggable],
        velocity: Vec3 =&gt; [Debuggable],
    }

    tracing_subscriber::fmt().init();

    use flax::serialize::{SerdeBuilder, SerializeFormat};
    tracing::info!(&quot;It works&quot;);

    let mut world = World::new();

    let mut rng = StdRng::seed_from_u64(239);

    let mut batch = BatchSpawn::new(16);

    batch.set(
        position(),
        (&amp;mut rng).sample_iter(Standard).map(|v: Vec3| v * 2.0),
    )?;
    batch.set(velocity(), (&amp;mut rng).sample_iter(Standard))?;
    batch.set(name(), (0..).map(|v| format!(&quot;id.{v}&quot;)))?;

    batch.spawn(&amp;mut world);

    let mut batch = BatchSpawn::new(8);

    batch.set(
        position(),
        (&amp;mut rng).sample_iter(Standard).map(|v: Vec3| v * 2.0),
    )?;
    batch.set(name(), (16..).map(|v| format!(&quot;id.{v}&quot;)))?;
    batch.spawn(&amp;mut world);

<span class="boring">}</span></code></pre></pre>
<p>We are interested in <code>name</code>, <code>position</code>, and <code>velocity</code>, nothing else, even if
it implements <code>Serialize</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (serializer, deserializer) = SerdeBuilder::new()
        .with(name())
        .with(position())
        .with(velocity())
        .build();

    let json =
        serde_json::to_string_pretty(&amp;serializer.serialize(&amp;world, SerializeFormat::RowMajor))?;

    // eprintln!(&quot;World: {json}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>When deserializing a world it is often of interest in merging it or
deserializing <em>into</em> another world.</p>
<p>This is supported through the <code>merge_with</code> function, which will migrate
colliding ids to new ones, returning a map in doing so.</p>
<p>The advantage of doing it this way is that the world is left untouched if
deserialization failed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    // An existing world with entities in it
    let mut world = World::new();

    let mut batch = BatchSpawn::new(32);

    batch.set(
        position(),
        (&amp;mut rng).sample_iter(Standard).map(|v: Vec3| v * 2.0),
    )?;
    batch.set(name(), (0..).map(|v| format!(&quot;other_id.{v}&quot;)))?;
    batch.spawn(&amp;mut world);

    let mut result = deserializer.deserialize(&amp;mut serde_json::Deserializer::from_str(&amp;json))?;

    // Merge `result` into `world`
    world.merge_with(&amp;mut result);

    // eprintln!(&quot;World: {world:#?}&quot;);

<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
