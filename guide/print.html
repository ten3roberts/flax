<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flax Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="fundamentals/index.html"><strong aria-hidden="true">1.</strong> Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/world.html"><strong aria-hidden="true">1.1.</strong> World</a></li><li class="chapter-item expanded "><a href="fundamentals/components.html"><strong aria-hidden="true">1.2.</strong> Components</a></li><li class="chapter-item expanded "><a href="fundamentals/metadata.html"><strong aria-hidden="true">1.3.</strong> Component metadata</a></li><li class="chapter-item expanded "><a href="fundamentals/query.html"><strong aria-hidden="true">1.4.</strong> Query</a></li><li class="chapter-item expanded "><a href="fundamentals/entity_query.html"><strong aria-hidden="true">1.5.</strong> EntityQuery</a></li><li class="chapter-item expanded "><a href="fundamentals/systems.html"><strong aria-hidden="true">1.6.</strong> Systems</a></li><li class="chapter-item expanded "><a href="fundamentals/schedule.html"><strong aria-hidden="true">1.7.</strong> Schedule</a></li><li class="chapter-item expanded "><a href="fundamentals/relations.html"><strong aria-hidden="true">1.8.</strong> Relations</a></li><li class="chapter-item expanded "><a href="fundamentals/builder.html"><strong aria-hidden="true">1.9.</strong> EntityBuilder</a></li><li class="chapter-item expanded "><a href="fundamentals/commandbuffer.html"><strong aria-hidden="true">1.10.</strong> CommandBuffer</a></li></ol></li><li class="chapter-item expanded "><a href="diving_deeper/index.html"><strong aria-hidden="true">2.</strong>  Diving deeper </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="diving_deeper/query.html"><strong aria-hidden="true">2.1.</strong> Query Advanced</a></li><li class="chapter-item expanded "><a href="diving_deeper/dynamic_components.html"><strong aria-hidden="true">2.2.</strong> Dynamic Components</a></li><li class="chapter-item expanded "><a href="diving_deeper/serde.html"><strong aria-hidden="true">2.3.</strong> Serialization</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flax Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Flax is an easy to use Entity Component System.</p>
<h2 id="what-is-an-ecs"><a class="header" href="#what-is-an-ecs">What is an ECS</a></h2>
<p>ECS, or Entity Component System is a design paradigm of where the state of the
program is structured around multiple <em>Entities</em>, where each entity may have
zero or more components attached to it.</p>
<p>Systems execute upon the entities and their components.</p>
<p>The main benefit of this priniciple is that the logic is separate from the data,
and new functionality can be added to existing entities and components.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>In Flax, there are 3 fundamental building blocks.</p>
<p><a href="https://docs.rs/flax/latest/flax/struct.Entity.html">Entity</a>. A unique identifier for the objects of the program. Has a managed lifecycle.</p>
<p><a href="https://docs.rs/flax/latest/flax/struct.Component.html">Component</a>, data which
can be added to an Entity. Has a unique Id, which works as the key for storing
and retrieving the value, and a strongly typed value.</p>
<p><a href="https://docs.rs/flax/latest/flax/struct.System.html">System</a> functions which
execute on the world or a group of entities. Provides the logic of the program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<p>This chapter goes through the basic of using Flax.</p>
<p>To get started, add <code>flax</code> to the <code>Cargo.toml</code> file</p>
<pre><code class="language-toml">flax = &quot;0.2&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world"><a class="header" href="#world">World</a></h1>
<p>The world holds the entities and components in the ECS.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut world = World::new();
<span class="boring">}
</span></code></pre></pre>
<p>Spawning an entity yields an <code>Entity</code> id.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let id = world.spawn();

    if world.is_alive(id) {
        println!(&quot;It is alive!&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p>When an entity is despawned, it can no longer be accessed.</p>
<p>Entity ids are versioned, which means that once an entity is despawned the index
in the storage may be reused, but it will have a different version, which
prevents dead entities to become alive at a later point in time. I.e; dead
entities stay dead, this is not a zombie apocalypse we are working with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    world.despawn(id)?;

    if world.is_alive(id) {
        println!(&quot;We've got a zombie on our hands&quot;);
    }

<span class="boring">}
</span></code></pre></pre>
<p>Many entities can be spawned at a time, which is easily demonstrated by this
iterator which takes entity ids from the world</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let ids = world.spawn_many().take(10).collect_vec();
    println!(&quot;ids: {ids:?}&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>A component represents data which is attached to an entity.</p>
<p><strong>Note</strong>: Compared to other Rust ECS implementations, a component is not the
same as the underlying type. This allows different components of the same
<em>datatype</em> to coexist without having to use newtypes and forward all traits, and
implement <code>Into</code> and <code>From</code> implementations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// Represents the position in the world
        position: (f32, f32),
    }

<span class="boring">}
</span></code></pre></pre>
<p>This in turn exposes a function that will return the component id, as component ids
are lazily allocated due to lack of compile time unique ids.</p>
<p>The component can be added, accessed and removed from entities using
<a href="https://docs.rs/flax/latest/flax/struct.World.html#method.set">World::set</a>,
<a href="https://docs.rs/flax/latest/flax/struct.World.html#method.get">World::get</a>, and
<a href="https://docs.rs/flax/latest/flax/struct.World.html#method.remove">World::remove</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let id = world.spawn();

    // Add a component to `id`
    world.set(id, position(), (1.0, 4.0))?;

    {
        let val = world.get(id, position())?;

        println!(&quot;The entity is at: {val:?}&quot;);
    }

    // This will overwrite the previous value
    world.set(id, position(), (1.0, 4.5))?;

    {
        // Mutate the component
        let mut pos = world.get_mut(id, position())?;
        pos.1 += 1.0;
    }

    println!(&quot;The entity is now at: {:?}&quot;, world.get(id, position())?);

<span class="boring">}
</span></code></pre></pre>
<p>Accessing a component mutably does not require a mutable access to the world, as
it uses an AtomicRefCell.</p>
<p>Multiple <em>different</em> components can be accessed simultaneously, even on the same
entity.</p>
<h2 id="default-components"><a class="header" href="#default-components">Default components</a></h2>
<p>Flax provides some opinionated default components to ease the communication
between different libraries and users.</p>
<ul>
<li><a href="https://docs.rs/flax/latest/flax/components/fn.name.html">name</a>: Provides a name for entities and components.</li>
<li><a href="https://docs.rs/flax/latest/flax/components/fn.child_of.html">child_of</a>: Default dataless hierarchy relation. See: <a href="https://ten3roberts.github.io/flax/guide/fundamentals/hierarchy.html">Hierarchy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-metadata"><a class="header" href="#component-metadata">Component metadata</a></h1>
<p>The keen eyed of you may have noticed that <code>ComponentId</code> is the same as
<code>Entity</code>.</p>
<p>This is a design choice; a component is also an entity, and as such, exists in
the world.</p>
<p>This brings some interesting possibilities which are not possible in other ECS
systems, mainly: components can have components.</p>
<p>This allows the components to be queried just as they were normal entities. This
allows reflection.</p>
<p>For example, a component can itself have a component which knows how to
<code>Debug::fmt</code> the component value, another component could be used to serialize a
value.</p>
<p>While components could be added to components through the conventional
[<code>World::set</code>] syntax, it can quickly become a spaghetti of <code>init</code> functions for
each library to add the required components, or metadata to the exported
components.</p>
<p>This is where the <a href="https://docs.rs/flax/latest/flax/macro.component.html">component</a> macro comes into play. The component function acquires a globally free <code>Entity</code> and assigns that to the strongly typed component.
When the component is first inserted into the world it can insert so called <em>metadata</em> to the component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// An entity's health.
        /// Provides the Debug bundle, which adds the `debug_visitor` component.
        health: f32 =&gt; [ flax::Debug ],
    }

    // After adding the component, the associate metadata of the `health`
    // component is added to the world.
    world.set(id, health(), 100.0)?;

    let component_name = world.get(health().id(), name())?;
    println!(&quot;The name of the component is {component_name:?}&quot;);

    // Print the state of the world
    println!(&quot;World: {world:#?}&quot;);
    // Prints:
    //
    // World: {
    //     1v2: {},
    //     2v1: {},
    //     3v1: {},
    //     4v1: {},
    //     5v1: {},
    //     6v1: {},
    //     7v1: {},
    //     8v1: {},
    //     9v1: {},
    //     10v1: {},
    //     11v1: {
    //         &quot;position&quot;: _,
    //         &quot;health&quot;: 100.0,
    //     },
    // }

<span class="boring">}
</span></code></pre></pre>
<p>The</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>component: type =&gt; [ Meta, Meta, Meta ]
<span class="boring">}
</span></code></pre></pre>
<p>syntax is used to add metadata to the component.</p>
<p>The <code>component</code> component, and the <code>name</code> component is always present.</p>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>If a component has the
<a href="https://docs.rs/flax/latest/flax/struct.Debug.html">flax::Debug</a> component, the
component and value for each entity will be present when debug formatting the
world.</p>
<h2 id="name"><a class="header" href="#name">Name</a></h2>
<p>Every component has a <code>name</code>, which is the same as the declaration.</p>
<h2 id="custom-metadata"><a class="header" href="#custom-metadata">Custom metadata</a></h2>
<p>Custom metadata can be added to a component by creating a struct which
implements <a href="https://docs.rs/flax/latest/flax/trait.MetaData.html">MetaData</a>,
which is responsible of adding the appropriate components.</p>
<p><strong>Note</strong>: Do not use conditional compilation for these structs as this leaks the
<code>cfg</code> directives to any uses of the metadata in the <code>component</code> macro. Instead,
conditionally add, or do not add, the component in the <code>attach</code> method.</p>
<p>A common example of this is <code>serde</code>, prefer to not add the <code>serializer</code>
component and still define <code>Serialize</code> and making it no-op when <code>serde</code> is not
enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">Query</a></h1>
<p>Queries allow efficient access and iteration over multiple components.</p>
<p>They allow iterating entities which have a certain set of components, and match
a certain filter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut world = World::new();

    component! {
        position: (f32, f32) =&gt; [ Debug ],
        health: f32 =&gt; [ Debug ],
    }

    // Spawn two entities
    let id = world.spawn();

    world.set(id, position(), (1.0, 4.0))?;
    world.set(id, health(), 100.0)?;

    let id2 = world.spawn();

    world.set(id2, position(), (-1.0, 4.0))?;
    world.set(id2, health(), 75.0)?;

    let mut query = Query::new((position(), health()));

    for (pos, health) in &amp;mut query.borrow(&amp;world) {
        println!(&quot;pos: {pos:?}, health: {health}&quot;);
    }

<span class="boring">}
</span></code></pre></pre>
<p>A query accepts any type which implements
<a href="https://docs.rs/flax/latest/flax/fetch/trait.Fetch.html">Fetch</a>:</p>
<ul>
<li>A component</li>
<li>A tuple of components</li>
<li><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.as_mut"><code>component.as_mut()</code></a> for mutable access</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt"><code>component.opt()</code></a> for an optional access, returns Option&lt;&amp;T&gt;,</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt"><code>component.as_mut().opt()</code></a> for an optional mutable access, returns Option&lt;&amp;mut T&gt;,</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or_default"><code>component.opt_or_default()</code></a> for an access which returns a default value if</li>
<li><a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or"><code>component.opt_or()</code></a> for an access which returns a provided value if
the current entity does not have the component.</li>
<li><a href="https://docs.rs/flax/latest/flax/fn.entities.html">entities</a> to return the
iterated <code>Entity</code> ids.</li>
<li>... and many more</li>
</ul>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>A query allows for filters, such as skipping entities which have a certain
components, or where the value of a component satisfies some condition.</p>
<p>The difference between using a query filter and a filter on the iterator is that
mutable components are not marked as modified if skipped by a query iterator.
This is because the <code>QueryIter</code> is not able to determine if a later <code>filter</code>
skipped the item. In addition, the query filters operate on ranges and can look
up modifications and alike for a group of entities, E.g; if all entities next to
each other are modified, only one range will be yielded, instead of each entity
separately.</p>
<p><strong>Note</strong>: It is not possible to access a component mutably and filter on it at
the same time.</p>
<p>Change detection is also supported and allows querying only over the entities
where a certain component changed.</p>
<p>The following example shows a query which will update the distance to origin
when an entity moves for every entity which are not despawned.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// Distance to origin
        distance: f32 =&gt; [ flax::Debug ],
    }

    tracing::info!(&quot;Spawning id3&quot;);
    let id3 = world.spawn();
    world.set(id3, position(), (5.0, 6.0))?;
    world.set(id3, health(), 5.0)?;

    for id in [id, id2, id3] {
        tracing::info!(&quot;Adding distance to {id}&quot;);
        world.set(id, distance(), 0.0)?;
    }

    let mut query = Query::new((entity_ids(), position(), distance().as_mut()))
        .filter(position().modified() &amp; health().gt(0.0));

    tracing::info!(&quot;Updating distances&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        tracing::info!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();
    }

<span class="boring">}
</span></code></pre></pre>
<p>The same query can be run again, but since all changes have been visited, it
yields nothing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    tracing::info!(&quot;Running query again&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        tracing::info!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();
    }
<span class="boring">}
</span></code></pre></pre>
<p>However, if the position were to be modified, the query would pick up that, and
only that change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    *world.get_mut(id2, position())? = (8.0, 3.0);

    tracing::info!(&quot;... and again&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        tracing::info!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();
    }

<span class="boring">}
</span></code></pre></pre>
<p>For situations where an <code>or</code> combined filter is used in conjunction with a fetch
of the same components, the filter may be attached directly to the query fetch
instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Instead of this:
        let query = Query::new((position(), health(), distance()))
            .filter(position().modified() | health().modified());

        // Do this:
        let query = Query::new((position().modified(), health().modified(), distance()));
<span class="boring">}
</span></code></pre></pre>
<h3 id="change-detection"><a class="header" href="#change-detection">Change detection</a></h3>
<ul>
<li><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.modified">modified</a> yields components which have been updated <strong>or</strong> inserted.</li>
<li><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.inserted">inserted</a> yields new components.</li>
<li><a href="https://docs.rs/flax/latest/flax/struct.Component.html#method.removed">removed</a> yields each entity for which the component was recently removed.</li>
</ul>
<p>All change detection is per query and based on when the query last executed.</p>
<h3 id="comparative-filter"><a class="header" href="#comparative-filter">Comparative filter</a></h3>
<p>In addition to change detection, filtering on value is also possible. See: <a href="https://docs.rs/flax/latest/flax/trait.CmpExt.html">CmpExt</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entityquery"><a class="header" href="#entityquery">EntityQuery</a></h1>
<p>Similar to a normal query, an
<a href="https://docs.rs/flax/latest/flax/struct.EntityQuery.html">EntityQuery</a> allows
simultanous access to multiple components using a fetch, but for a single,
already known entity.</p>
<p>This is useful when dealing with static resource entities and allowing systems
to efficiently access the resources it needs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        window_width: f32,
        window_height: f32,
        allow_vsync: bool,

        resources,
    }

    Entity::builder()
        .set(window_width(), 800.0)
        .set(window_height(), 600.0)
        .set(allow_vsync(), false)
        // Since `resources` is static, it is not required to spawn it
        .append_to(&amp;mut world, resources())
        .unwrap();

    let query = Query::new((
        window_width().modified(),
        window_height().modified(),
        allow_vsync().modified(),
    ))
    .entity(resources());

    let mut window_system = System::builder()
        .with(query)
        .build(|mut q: EntityBorrow&lt;_&gt;| {
            if let Ok((width, height, allow_vsync)) = q.get() {
                tracing::info!(width, height, allow_vsync, &quot;Config changed&quot;);
            } else {
                tracing::info!(&quot;No config change&quot;);
            }
        });

    window_system.run_on(&amp;mut world);
    window_system.run_on(&amp;mut world);
    world.set(resources(), window_height(), 720.0)?;
    window_system.run_on(&amp;mut world);

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Having to both keep queries around, and their logic is tedious and error prone.</p>
<p>Systems aid in organizing your applications logic and required data.</p>
<p>Each system represents a set of data, like queries or view into the world, or a
commandbuffer, and a function which will be executed.</p>
<p>In the previous chapter, the &quot;update distance from positions&quot;, which was reused
thrice could be turned into a query.</p>
<p>Instead of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        /// Distance to origin
        distance: f32 =&gt; [ flax::Debug ],
    }

    tracing::info!(&quot;Spawning id3&quot;);
    let id3 = world.spawn();
    world.set(id3, position(), (5.0, 6.0))?;
    world.set(id3, health(), 5.0)?;

    for id in [id, id2, id3] {
        tracing::info!(&quot;Adding distance to {id}&quot;);
        world.set(id, distance(), 0.0)?;
    }

    let mut query = Query::new((entity_ids(), position(), distance().as_mut()))
        .filter(position().modified() &amp; health().gt(0.0));

    tracing::info!(&quot;Updating distances&quot;);
    for (id, pos, dist) in &amp;mut query.borrow(&amp;world) {
        tracing::info!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
        *dist = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();
    }

<span class="boring">}
</span></code></pre></pre>
<p>We get this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut update_dist = System::builder()
        .with_name(&quot;update_distance&quot;)
        .with(query)
        .build(
            |mut query: QueryBorrow&lt;(_, Component&lt;(f32, f32)&gt;, Mutable&lt;f32&gt;), _&gt;| {
                for (id, pos, dist) in &amp;mut query {
                    tracing::info!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
                    *dist = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();
                }
            },
        );

    update_dist.run_on(&amp;mut world);
<span class="boring">}
</span></code></pre></pre>
<h2 id="for-each"><a class="header" href="#for-each">For each</a></h2>
<p>If the systems sole purpose it to execute an action for each element, the
<code>for_each</code> shorthand can be used. This is only possible if the system uses a
single query.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut update_dist = System::builder()
        .with_name(&quot;update_distance&quot;)
        .with(
            Query::new((entity_ids(), position(), distance().as_mut()))
                .filter(position().modified()),
        )
        .for_each(|(id, pos, dist)| {
            tracing::debug!(&quot;Updating distance for {id} with position: {pos:?}&quot;);
            *dist = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();
        });

    for _ in 0..16 {
        update_dist.run_on(&amp;mut world);
    }

<span class="boring">}
</span></code></pre></pre>
<h2 id="system-access"><a class="header" href="#system-access">System access</a></h2>
<p>Contrary to using a query directly, the <code>world</code> is not needed to prepare a
query. This is because the world is contained inside the <code>QueryData</code> argument.</p>
<p>This ensures a system will only access the components in the associated queries,
which allows for paralellizing system execution.</p>
<p>If access to the whole world is required, use <code>with_world</code>.</p>
<p>Similarly, <code>with_cmd</code> allows access to the commandbuffer in the system, which is
used for deferred sets, removes, or spawns.</p>
<p><strong>Note</strong>: Systems which access the world will not paralellize with other systems
as it may access anything.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Despawn all entities with a distance &gt; 50
    let despawn = System::builder()
        .with_name(&quot;delete_outside_world&quot;)
        .with(Query::new((entity_ids(), distance())).filter(distance().gt(50.0)))
        .write::&lt;CommandBuffer&gt;()
        .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
            for (id, &amp;dist) in &amp;mut q {
                tracing::info!(&quot;Despawning {id} at: {dist}&quot;);
                cmd.despawn(id);
            }
        });

    let debug_world = System::builder()
        .with_name(&quot;debug_world&quot;)
        .read::&lt;World&gt;()
        .build(|world: &amp;_| {
            tracing::debug!(&quot;World: {world:?}&quot;);
        });

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schedule"><a class="header" href="#schedule">Schedule</a></h1>
<p>A schedule allows execution and paralellization of multiple systems.</p>
<p>The systems discussed in the previous chapter can be put into a schedule to
contain the logic and order of execution.</p>
<p>In addition to executing systems one after another, a schedule can automatically
paralellize execution and run multiple systems at the same time using
<a href="https://docs.rs/rayon/latest/rayon/">rayon</a> such that the observable effects
occurr order.</p>
<p>In other words, if two systems have queries which do not access the same
archetype and components, they will run in paralell. If an archetype reads a
value which is written by another system declared before, they will run in
sequence.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let despawn = System::builder()
        .with_name(&quot;delete_outside_world&quot;)
        .with(Query::new((entity_ids(), distance())).filter(distance().gt(50.0)))
        .write::&lt;CommandBuffer&gt;()
        .build(|mut q: QueryBorrow&lt;_, _&gt;, cmd: &amp;mut CommandBuffer| {
            for (id, &amp;dist) in &amp;mut q {
                tracing::info!(&quot;Despawning {id} at: {dist}&quot;);
                cmd.despawn(id);
            }
        });

    let debug_world = System::builder()
        .with_name(&quot;debug_world&quot;)
        .read::&lt;World&gt;()
        .build(|world: &amp;_| {
            tracing::debug!(&quot;World: {world:?}&quot;);
        });


    component! {
        is_static: () =&gt; [ flax::Debug ],
    }

    // Spawn 150 static entities, which wont move
    let mut rng = StdRng::seed_from_u64(42);

    for _ in 0..150 {
        let pos = (rng.gen_range(-5.0..5.0), rng.gen_range(-5.0..5.0));
        Entity::builder()
            .set(position(), pos)
            .set_default(distance())
            .set_default(is_static())
            .spawn(&amp;mut world);
    }

    // Since this system will move non static entities out from the origin, they will
    // eventually be despawned
    let move_out = System::builder()
        .with_name(&quot;move_out&quot;)
        .with(Query::new(position().as_mut()).filter(is_static().without()))
        .for_each(|pos| {
            let mag = (pos.0 * pos.0 + pos.1 * pos.1).sqrt();

            let dir = (pos.0 / mag, pos.1 / mag);

            pos.0 += dir.0;
            pos.1 += dir.1;
        });

    // Spawn new entities with a random position each frame
    let spawn = System::builder()
        .with_name(&quot;spawner&quot;)
        .write::&lt;CommandBuffer&gt;()
        .build(move |cmd: &amp;mut CommandBuffer| {
            for _ in 0..100 {
                let pos = (rng.gen_range(-10.0..10.0), rng.gen_range(-10.0..10.0));
                tracing::info!(&quot;Spawning new entity at: {pos:?}&quot;);
                Entity::builder()
                    .set(position(), pos)
                    .set_default(distance())
                    .spawn_into(cmd);
            }
        });

    let mut frame_count = 0;

    // Count the number of entities in the world and log it
    let count = System::builder()
        .with_name(&quot;count&quot;)
        .with(Query::new(()))
        .build(move |mut query: QueryBorrow&lt;()&gt;| {
            let count: usize = query.iter_batched().map(|v| v.len()).sum();
            tracing::info!(&quot;[{frame_count}]: {count}&quot;);
            frame_count += 1;
        });

    // Assemple the schedule, takes care of dependency management
    let mut schedule = Schedule::builder()
        .with_system(update_dist)
        .with_system(despawn)
        .with_system(spawn)
        .with_system(move_out)
        .with_system(debug_world)
        .with_system(count)
        .build();

    tracing::info!(&quot;{schedule:#?}&quot;);

    for i in 0..20 {
        tracing::info!(&quot;Frame: {i}&quot;);
        tracing::info!(&quot;Batches: {:#?}&quot;, schedule.batch_info(&amp;mut world));
        schedule.execute_par(&amp;mut world)?;
        // sleep(Duration::from_secs_f32(0.1));
    }

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relations"><a class="header" href="#relations">Relations</a></h1>
<p>Relations such as hierarchies or entity-entity connections are a common way to structure entities in an application or game,
such as nested UI elements or entities in a game world which move along with
their parents.</p>
<p>Flax has first class support for hierarchies, called <code>Relations</code>.</p>
<p>A relation in Flax is represented by a parameterized component containing the
<code>object</code>, i.e; parent added to the <code>subject</code>, i.e; child entity.</p>
<p>Think of it as the component accepting an argument entity prior to adding it to
another entity.</p>
<p>Relations are declared using the
<a href="https://docs.rs/flax/latest/flax/macro.component.html">component</a> macro</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        child_of(parent): () =&gt; [Debug],
        spring_joint(other): f32 =&gt; [Debug],
    }

    let mut world = World::new();

    let parent = Entity::builder()
        .set(name(), &quot;Parent&quot;.into())
        .spawn(&amp;mut world);

    let child1 = Entity::builder()
        .set(name(), &quot;Child1&quot;.into())
        .set_default(child_of(parent))
        .spawn(&amp;mut world);

    let child2 = Entity::builder()
        .set(name(), &quot;Child2&quot;.into())
        .set_default(child_of(parent))
        .spawn(&amp;mut world);

<span class="boring">}
</span></code></pre></pre>
<p>Important to note is that the same <code>child_of</code> component with different <code>object</code>
arguments are distinct, and can as such exist on an entity at the same time,
allowing many-many relationsships between entities;</p>
<p>There is no limatation of the number of relations an entity can have. As such,
an entity can have multiple relations to other entities, allowing for any kind of graphs inside the ecs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let parent2 = Entity::builder()
        .set(name(), &quot;Parent2&quot;.into())
        .spawn(&amp;mut world);

    world.set(child1, child_of(parent2), ())?;

    tracing::info!(&quot;World: {world:#?}&quot;);

    // Connect child1 with two entities via springs of different strength
    world.set(child1, spring_joint(child2), 1.5)?;
    world.set(child1, spring_joint(parent2), 7.4)?;

    tracing::info!(
        &quot;Connections from child1({child1}): {:?}&quot;,
        Query::new(relations_like(spring_joint))
            .borrow(&amp;world)
            .get(child1)?
            .collect_vec()
    );

<span class="boring">}
</span></code></pre></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>Since relations are normal components, they can be used in a query as normal, or
used to exclude components.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let children_of_parent = Query::new(entity_ids())
        .with(child_of(parent))
        .borrow(&amp;world)
        .iter()
        .collect_vec();

    tracing::info!(&quot;Children: {children_of_parent:?}&quot;);

    let all_children = Query::new(entity_ids())
        .filter(child_of.with_relation())
        .borrow(&amp;world)
        .iter()
        .collect_vec();

    tracing::info!(&quot;Children: {all_children:?}&quot;);

    let roots = Query::new(entity_ids())
        .filter(child_of.without_relation())
        .borrow(&amp;world)
        .iter()
        .collect_vec();

    tracing::info!(&quot;Roots: {roots:?}&quot;);

<span class="boring">}
</span></code></pre></pre>
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<p>When an entity is despawned, all relations to it present on other components
will be removed and dropped. As such, no entity will have a relation to an
entity which does not exist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    tracing::info!(
        &quot;has relation to: {parent2}: {}&quot;,
        world.has(child1, child_of(parent2))
    );

    world.despawn(parent2)?;

    tracing::info!(
        &quot;has relation to: {parent2}: {}&quot;,
        world.has(child1, child_of(parent2))
    );

    tracing::info!(&quot;World: {world:#?}&quot;);
    world.despawn_recursive(parent, child_of)?;

    tracing::info!(&quot;World: {world:#?}&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-builder"><a class="header" href="#entity-builder">Entity Builder</a></h1>
<p>The <a href="https://docs.rs/flax/latest/flax/struct.EntityBuilder.struct">EntityBuilder</a>
allows you to incrementally construct an entity by adding components and <em>then</em>
inserting it into the world. This provides both better ergonomics and efficiency
as the entity does not bounce around archetypes.</p>
<p>Additionally, the entity builder allows constructing an entity in the absence of
the world, like a function which only creates the <code>EntityBuilder</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        health: f32 =&gt; [Debug],
        position: (f32, f32) =&gt; [Debug],
        is_player: () =&gt; [Debug],
    }

    let mut world = World::new();

    // Instead of this
    let player = world.spawn();
    world.set(player, health(), 100.0).unwrap();
    world.set(player, position(), (5.0, 2.3)).unwrap();
    world.set(player, is_player(), ()).unwrap();
    world.set(player, name(), &quot;Player&quot;.into()).unwrap();

    tracing::info!(&quot;Player: {:#?}&quot;, world.format_entities(&amp;[player]));
    world.despawn(player).unwrap();

    // Do this
    let player = Entity::builder()
        .set(health(), 100.0)
        .set(position(), (5.0, 2.3))
        .tag(is_player())
        .set(name(), &quot;Player&quot;.into())
        .spawn(&amp;mut world);

    tracing::info!(&quot;Player: {:#?}&quot;, world.format_entities(&amp;[player]));

<span class="boring">}
</span></code></pre></pre>
<p>When the entity builder is spawned, the held components are moved out into the
matching archetype in the world.</p>
<p>This means the entity builder is cleared and ready to insert more components.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut builder = Entity::builder();
    let mut rng = StdRng::seed_from_u64(42);

    let enemies = (0..10)
        .map(|i| {
            builder
                .set(health(), rng.gen_range(50..100) as f32)
                .set(
                    position(),
                    (rng.gen_range(-10.0..10.0), rng.gen_range(-10.0..10.0)),
                )
                .set(name(), format!(&quot;Enemy.{i}&quot;))
                .spawn(&amp;mut world)
        })
        .collect_vec();

    tracing::info!(&quot;Enemies: {enemies:?}&quot;);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut query = Query::new((name(), position(), is_player().opt(), health()));
    for (name, pos, is_player, health) in &amp;mut query.borrow(&amp;world) {
        tracing::info!(&quot;name: {name}, pos: {pos:?}, player: {is_player:?}, health: {health}&quot;);
    }

    // Or to only get the non players

    {
        let mut query = Query::new((name(), position(), health())).without(is_player());
        info_span!(&quot;enemies&quot;);
        for (name, pos, health) in &amp;mut query.borrow(&amp;world) {
            tracing::info!(&quot;name: {name}, pos: {pos:?}, health: {health}&quot;);
        }
    }

<span class="boring">}
</span></code></pre></pre>
<h2 id="batch-spawn"><a class="header" href="#batch-spawn">Batch Spawn</a></h2>
<p>If inserting <strong>many</strong> entities of the same type, it is more efficient to let the world know about
the coming components and insert everything at once.</p>
<p>The batch spawn allows spawning many entities with the same component types at
once by inserting columns of each component type. This is akin to the native
format of the archetype storage and is thus maximally efficient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let mut trees = BatchSpawn::new(10000);
    trees
        .set(name(), (0..).map(|i| format!(&quot;Tree.{i}&quot;)))
        .expect(&quot;Invalid length&quot;);

    trees
        .set(
            position(),
            (0..).map(|i| {
                let f = i as f32 / 32.0;
                (f.cos() * (1.0 + f / 2.0), f.sin() * (1.0 + f / 2.0))
            }),
        )
        .expect(&quot;Invalid length&quot;);

    let trees = trees.spawn(&amp;mut world);

    tracing::info!(&quot;Trees: {:#?}&quot;, world.format_entities(&amp;trees[0..100]));

<span class="boring">}
</span></code></pre></pre>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<p>In the previous chapter, hierarchies were constructed by adding a relation to an
entity to the child entity.</p>
<p>The entity builder allows construction of hierarchies before being spawned into
the world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    let id = Entity::builder()
        .set(name(), &quot;parent&quot;.into())
        .attach(
            child_of,
            Entity::builder()
                .set(name(), &quot;child1&quot;.into())
                .attach(child_of, Entity::builder().set(name(), &quot;child1.1&quot;.into())),
        )
        .attach(child_of, Entity::builder().set(name(), &quot;child2&quot;.into()))
        .spawn(&amp;mut world);

    tracing::info!(&quot;Parent: {id}&quot;);

    tracing::info!(&quot;World: {world:#?}&quot;);

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commandbuffer"><a class="header" href="#commandbuffer">CommandBuffer</a></h1>
<p>The commandbuffer allows deferred modification of the world.</p>
<p>This is useful in queries where the world is currently being iterated over, or
in other situations where a mutable reference to the world is not available.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        position: Vec2,
    }

    let mut world = World::new();

    let mut cmd = CommandBuffer::new();

    cmd.spawn(Entity::builder().set(name(), &quot;a&quot;.into()));

    cmd.apply(&amp;mut world)?;

    let id = Query::new(entity_ids())
        .filter(name().eq(&quot;a&quot;.into()))
        .borrow(&amp;world)
        .iter()
        .next()
        .ok_or(eyre::eyre!(&quot;Missing entity&quot;))?;

    cmd.set(id, position(), vec2(32.0, 2.6));
    let id2 = world.spawn();

    cmd.spawn_at(
        id,
        EntityBuilder::new()
            .set(name(), &quot;b&quot;.into())
            .set(position(), vec2(4.6, 8.4)),
    );

    cmd.remove(id2, position());

    cmd.apply(&amp;mut world)?;

    cmd.set(id2, child_of(id), ());

    // Execute this function when the commandbuffer is applied
    cmd.defer(move |w| {
        w.despawn_recursive(id, child_of)?;
        Ok(())
    });

    cmd.apply(&amp;mut world)?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="usage-with-schedule"><a class="header" href="#usage-with-schedule">Usage with schedule</a></h2>
<p>A schedule contains a commandbuffer which is available in systems through
<code>.write::&lt;CommandBuffer&gt;()</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        world_matrix: Mat4 =&gt; [Debug],
    }

    // Make sure there are always 64 entities in the world
    let mut rng = StdRng::seed_from_u64(42);
    let spawner = System::builder()
        .with_name(&quot;spawn_entities&quot;)
        .with(Query::new(()))
        .write::&lt;CommandBuffer&gt;()
        .build(move |mut q: QueryBorrow&lt;()&gt;, cmd: &amp;mut CommandBuffer| {
            let count = q.count();

            for _ in count..64 {
                tracing::info!(&quot;Spawning new entity&quot;);
                cmd.spawn(
                    Entity::builder()
                        .set(name(), &quot;entity&quot;.to_string())
                        .set(position(), rng.gen()),
                );
            }
        });

    // Ensure a world matrix to each entity with a position
    let add_world_matrix = System::builder()
        .with_name(&quot;add_world_matrix&quot;)
        .with(Query::new((entity_ids(), position())).without(world_matrix()))
        .write::&lt;CommandBuffer&gt;()
        .build(
            |mut q: QueryBorrow&lt;(EntityIds, Component&lt;Vec2&gt;), _&gt;, cmd: &amp;mut CommandBuffer| {
                for (id, pos) in &amp;mut q {
                    tracing::info!(&quot;Adding world matrix to {id}&quot;);
                    cmd.set(id, world_matrix(), Mat4::from_translation(pos.extend(0.0)));
                }
            },
        );

    // Update the world matrix if position changes
    let update_world_matrix = System::builder()
        .with_name(&quot;update_world_matrix&quot;)
        .with(
            Query::new((entity_ids(), position(), world_matrix().as_mut()))
                .filter(position().modified()),
        )
        .for_each(|(id, pos, ltw)| {
            tracing::info!(&quot;Updating world matrix for {id}&quot;);
            *ltw = Mat4::from_translation(pos.extend(0.0));
        });

    let mut schedule = Schedule::builder()
        .with_system(spawner)
        .flush()
        .with_system(add_world_matrix)
        .flush()
        .with_system(update_world_matrix)
        .build();

    schedule
        .execute_par(&amp;mut world)
        .wrap_err(&quot;Failed to run schedule&quot;)?;

<span class="boring">}
</span></code></pre></pre>
<p>The commandbuffer will be applied at the end of the schedule automatically.</p>
<p><code>flush</code> can be used to apply the commandbuffer to make the modifications visible
to the following systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diving-deeper"><a class="header" href="#diving-deeper">Diving deeper</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-query"><a class="header" href="#advanced-query">Advanced query</a></h1>
<p>A query is a combination of a
<a href="https://docs.rs/flax/latest/flax/traits.Fetch"><code>Fetch</code></a> and a
<a href="https://docs.rs/flax/latest/flax/traits.Filter"><code>Filter</code></a> in unison with a state.</p>
<p>The most common kind of <code>Fetch</code> is the component and the tuple fetch. The tuple
combines multiple fetches into a single one.</p>
<p>A tuple of components, or any other <code>Fetch</code> will only yield entities which match
the full tuple, I.e;</p>
<h2 id="optional-query"><a class="header" href="#optional-query">Optional query</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    // Entities with mass
    (0..10).for_each(|i| {
        builder
            .set(name(), format!(&quot;Entity.{i}&quot;))
            .set(position(), rng.gen::&lt;Vec3&gt;() * 10.0)
            .set(velocity(), rng.gen())
            .set(mass(), rng.gen_range(10..30) as f32)
            .spawn(&amp;mut world);
    });

    // Entities without mass
    (0..100).for_each(|i| {
        builder
            .set(name(), format!(&quot;Entity.{i}&quot;))
            .set(position(), rng.gen::&lt;Vec3&gt;() * 0.5)
            .set(velocity(), rng.gen())
            .spawn(&amp;mut world);
    });

    // Since this query accessed `position`, `velocity` **and** `mass` only the
    // first group of entities will be matched
    for (pos, vel, mass) in &amp;mut Query::new((position(), velocity(), mass())).borrow(&amp;world) {
        tracing::info!(&quot;pos: {pos}, vel: {vel}, mass: {mass}&quot;);
    }

<span class="boring">}
</span></code></pre></pre>
<p>Will only yield entities which have both position and velocity.</p>
<p>By adding <code>.opt()</code> to any fetch, you convert it to an <code>Option&lt;T&gt;</code> where <code>T</code> is
the value yielded by the underlying fetch</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    // Use an optional fetch to yield an `Option&lt;T&gt;`, works for any query
    for (pos, vel, mass) in &amp;mut Query::new((position(), velocity(), mass().opt())).borrow(&amp;world) {
        if mass.is_some() {
            tracing::info!(&quot;Has mass&quot;);
        }
        tracing::info!(&quot;pos: {pos}, vel: {vel}, mass: {mass:?}&quot;);
    }

<span class="boring">}
</span></code></pre></pre>
<p>However, it can still be cumbersome to deal with the option, especially since
components yield references, which can not be combined with
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a></p>
<p>The <a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or_default"><code>opt_or_default</code></a> combinator can be used, or <a href="https://docs.rs/flax/latest/flax/trait.FetchExt.html#method.opt_or"><code>opt_or</code></a> to provide your custom value if the entity does not have the specified component.</p>
<p>There only work for fetches which return a shared reference, as the provided
default is also returned by reference. For when there is an owned value, consider using the builting <code>Option::unwrap_or_default</code>.</p>
<p>This combinator is useful when writing systems which may need to operate on entities which lack some components, such as physics where the entity may not have a rotation.</p>
<h2 id="change-detection-1"><a class="header" href="#change-detection-1">Change detection</a></h2>
<p>Every time a component is modified, either through <a href="https://docs.rs/flax/latest/flax/struct.World#method.get_mut"><code>World::get_mut</code></a>, or a query, a <code>Modified</code> event is added to the affected entities.</p>
<p>Similarly, <code>set</code> when the component did not previously exist, and new entities will create an <code>Inserted</code> event.</p>
<p><code>Removal</code> events are created by
<a href="https://docs.rs/flax/latest/flax/struct.World#method.remove"><code>World::remove</code></a>.</p>
<p>The following example makes use of optional combinators and change detection to
handle a 3d world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    component! {
        rotation: Quat,
        scale: Vec3,
        world_matrix: Mat4 =&gt; [Debug],
    }

    let create_world_matrix = System::builder()
        .with_name(&quot;add_world_matrix&quot;)
        .with(
            Query::new(entity_ids())
                .with(position())
                .without(world_matrix()),
        )
        .write::&lt;CommandBuffer&gt;()
        .build(
            |mut query: QueryBorrow&lt;EntityIds, _&gt;, cmd: &amp;mut CommandBuffer| {
                for id in &amp;mut query {
                    tracing::info!(&quot;Adding world matrix to {id}&quot;);
                    cmd.set(id, world_matrix(), Mat4::IDENTITY);
                }
            },
        );

    let update_world_matrix = System::builder()
        .with_name(&quot;update_world_matrix&quot;)
        .with(
            Query::new((
                entity_ids(),
                world_matrix().as_mut(),
                position(),
                rotation().opt_or_default(),
                scale().opt_or(Vec3::ONE),
            ))
            .filter(position().modified() | rotation().modified() | scale().modified()),
        )
        .for_each(|(id, world_matrix, pos, rot, scale)| {
            tracing::info!(&quot;Updating world matrix for: {id} {pos} {rot} {scale}&quot;);
            *world_matrix = Mat4::from_scale_rotation_translation(*scale, *rot, *pos);
        });

    let mut schedule = Schedule::builder()
        .with_system(create_world_matrix)
        .flush()
        .with_system(update_world_matrix)
        .build();

    let all_ids = Query::new(entity_ids()).borrow(&amp;world).iter().collect_vec();

    for _ in 0..10 {
        schedule
            .execute_par(&amp;mut world)
            .expect(&quot;Failed to execute schedule&quot;);

        for _ in 0..32 {
            let id = *all_ids.choose(&amp;mut rng).expect(&quot;no ids&quot;);
            let mut pos = world.get_mut(id, position())?;
            // Move a bit away from origin
            let dir = pos.normalize();
            *pos += dir * rng.gen::&lt;f32&gt;();
            drop(pos);

            let mut scale = world.entry(id, scale())?.or_insert(Vec3::ONE);
            *scale *= 1.1;
        }

        sleep(Duration::from_secs(1))
    }

    tracing::info!(&quot;World: {world:#?}&quot;);

<span class="boring">}
</span></code></pre></pre>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h3>
<pre><code>Each `ChangeEvent` consists of a subslice of adjacent entities in the same
archetype, the change type, and when the change occurred.

Two change events where the entities are adjacent will be joined into a single
one will be joined. This means the change list is always rather small compared
to the number of changing entities (especially compared to using a `HashSet`).

The following example combines optional queries with change detection to create
a small physic calculation.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-components"><a class="header" href="#dynamic-components">Dynamic components</a></h1>
<p>A component is nothing more than a type safe entity id.</p>
<p>The <a href="https://docs.rs/flax/latest/flax/macro.component.html">component</a> uses a
lazily acquired entity. It does not require the world since the entity is
spawned in the <code>STATIC</code> global namespace which is shared across all worlds.</p>
<p>It is entirely possible to create a component at runtime for e.g; a local system.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    registry().with(HierarchicalLayer::default()).init();

    let mut world = World::new();

    let position: Component&lt;Vec2&gt; = world.spawn_component(&quot;position&quot;, |info| {
        let mut buf = ComponentBuffer::new();
        &lt;Debug as MetaData&lt;Vec2&gt;&gt;::attach(info, &amp;mut buf);
        buf
    });

    let id = Entity::builder()
        .set(position, vec2(1.0, 6.4))
        .spawn(&amp;mut world);

    tracing::info!(&quot;world: {world:#?}&quot;);

    // When `position` is despawned, it is removed from all entities.
    // This ensured that dead components never exist
    world.despawn(position.id())?;

    tracing::info!(&quot;world: {world:#?}&quot;);

    world.despawn(id)?;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>meta</code> allows the user to provide a function to attach extra components to
the entity. This is used by the <code>=&gt; [ty, ty]</code> syntax for the <code>component</code> macro.</p>
<p>The world will automatically manage the lifetime of the component to ensure that
no entity has invalid components attached to it.</p>
<h2 id="relations-1"><a class="header" href="#relations-1">Relations</a></h2>
<p>As a component is just a normal entity you can add an entity to another entity.
Such as adding a parent entity to the children entities.</p>
<p>However, while this method allows quick and easy entity hierarchies, there is no
notion of what the entity represents, and no way to distinguish it from another
component.</p>
<p>This is where component parameterization comes to play.</p>
<p>An entity is <code>64</code> bits in size, sufficient for holding the <code>kind</code>, <code>index</code>, and
<code>generation</code>.</p>
<p>However, since the world manages the lifetime of the component, the generation
of <code>32</code> bits is freed up, which allows other data to be stored, such as another
entity id.</p>
<p>This allows the upper bits of a component(<em>entity</em>) id to contain another
entity as the generation is not needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    #[derive(Debug, Clone)]
    struct RelationData {
        // This allows you to add extra data to the child in the relation
        distance: f32,
    }

    let child_of = world.spawn_relation::&lt;RelationData&gt;(&quot;child_of&quot;, |info| {
        let mut buf = ComponentBuffer::new();
        &lt;Debug as MetaData&lt;RelationData&gt;&gt;::attach(info, &amp;mut buf);
        buf
    });

    let parent = world.spawn();

    let child = Entity::builder()
        .set(child_of(parent), RelationData { distance: 1.0 })
        .spawn(&amp;mut world);

    let data = world.get(child, child_of(parent))?;

    tracing::info!(&quot;Relation distance: {:?}&quot;, data.distance);

    drop(data);

    world.despawn(parent)?;
    assert!(world.get(child, child_of(parent)).is_err());

<span class="boring">}
</span></code></pre></pre>
<p>When despawning either the relation component or object entity, the &quot;parent&quot;,
the component is removed from all entities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and deserialization</a></h1>
<p>While the built in reflection system could be used for serialization, similar
to <code>Debug</code>, deserialization can not. This is because the lazy registration of
components mean that the world may not know of the componenets deserialization
upfront, especially since deserialization yields a new world.</p>
<p>In addition, having serialization be <em>implicit</em> may lead to components not being
serialized when they are expected to, or components which should not be
serialized to be written to disk, such as local state. As such, it leads to
unexpected, undesirable, or downright insecure behavior.</p>
<p>A similar story is to be found for <em>deserialization</em>, where program behaviour
can be intrusively modified due to anything being able to be deserialized and
put into the world.</p>
<p>As such [de]serialization is explicit and requires registering a subset of
components.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    component! {
        position: Vec3 =&gt; [Debug],
        velocity: Vec3 =&gt; [Debug],
    }
    tracing_subscriber::fmt().init();

    use flax::serialize::{SerdeBuilder, SerializeFormat};
    tracing::info!(&quot;It works&quot;);

    let mut world = World::new();

    let mut rng = StdRng::seed_from_u64(239);

    let mut batch = BatchSpawn::new(16);

    batch.set(
        position(),
        (&amp;mut rng).sample_iter(Standard).map(|v: Vec3| v * 2.0),
    )?;
    batch.set(velocity(), (&amp;mut rng).sample_iter(Standard))?;
    batch.set(name(), (0..).map(|v| format!(&quot;id.{v}&quot;)))?;

    batch.spawn(&amp;mut world);

    let mut batch = BatchSpawn::new(8);

    batch.set(
        position(),
        (&amp;mut rng).sample_iter(Standard).map(|v: Vec3| v * 2.0),
    )?;
    batch.set(name(), (16..).map(|v| format!(&quot;id.{v}&quot;)))?;
    batch.spawn(&amp;mut world);

<span class="boring">}
</span></code></pre></pre>
<p>We are interested in <code>name</code>, <code>position</code>, and <code>velocity</code>, nothing else, even if
it implements <code>Serialize</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (serializer, deserializer) = SerdeBuilder::new()
        .with(name())
        .with(position())
        .with(velocity())
        .build();

    let json =
        serde_json::to_string_pretty(&amp;serializer.serialize(&amp;world, SerializeFormat::RowMajor))?;

    // eprintln!(&quot;World: {json}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>When deserializing a world it is often of interest in merging it or
deserializing <em>into</em> another world.</p>
<p>This is supported through the <code>merge_with</code> function, which will migrate
colliding ids to new ones, returning a map in doing so.</p>
<p>The advantage of doing it this way is that the world is left untouched if
deserialization failed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    // An existing world with entities in it
    let mut world = World::new();

    let mut batch = BatchSpawn::new(32);

    batch.set(
        position(),
        (&amp;mut rng).sample_iter(Standard).map(|v: Vec3| v * 2.0),
    )?;
    batch.set(name(), (0..).map(|v| format!(&quot;other_id.{v}&quot;)))?;
    batch.spawn(&amp;mut world);

    let mut result = deserializer.deserialize(&amp;mut serde_json::Deserializer::from_str(&amp;json))?;

    // Merge `result` into `world`
    world.merge_with(&amp;mut result);

    // eprintln!(&quot;World: {world:#?}&quot;);

<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
